{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ssm_simulators","text":"<p>Python Package which collects simulators for Sequential Sampling Models.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The <code>ssms</code> package serves two purposes. </p> <ol> <li> <p>Easy access to fast simulators of sequential sampling models</p> </li> <li> <p>Support infrastructure to construct training data for various approaches to likelihood / posterior amortization</p> </li> </ol> <p>We provide two minimal examples here to illustrate how to use each of the two capabilities.</p>"},{"location":"#install","title":"Install","text":"<p>Let's start with installing the <code>ssms</code> package.</p> <p>You can do so by typing,</p> <p><code>pip install git+https://github.com/AlexanderFengler/ssm_simulators</code></p> <p>in your terminal.</p> <p>Below you find a basic tutorial on how to use the package.</p>"},{"location":"#tutorial","title":"Tutorial","text":"<pre><code># Import necessary packages\nimport numpy as np\nimport pandas as pd\nimport ssms\n</code></pre>"},{"location":"#using-the-simulators","title":"Using the Simulators","text":"<p>Let's start with using the basic simulators.  You access the main simulators through the  <code>ssms.basic_simulators.simulator</code> function.</p> <p>To get an idea about the models included in <code>ssms</code>, use the <code>config</code> module. The central dictionary with metadata about included models sits in <code>ssms.config.model_config</code>. </p> <pre><code># Check included models\nlist(ssms.config.model_config.keys())[:10]\n</code></pre> <pre><code>['ddm',\n 'ddm_legacy',\n 'angle',\n 'weibull',\n 'levy',\n 'levy_angle',\n 'full_ddm',\n 'ornstein',\n 'ornstein_angle',\n 'ddm_sdv']\n</code></pre> <pre><code># Take an example config for a given model\nssms.config.model_config['ddm']\n</code></pre> <pre><code>{'name': 'ddm',\n 'params': ['v', 'a', 'z', 't'],\n 'param_bounds': [[-3.0, 0.3, 0.1, 0.0], [3.0, 2.5, 0.9, 2.0]],\n 'boundary': &lt;function ssms.basic_simulators.boundary_functions.constant(t=0)&gt;,\n 'n_params': 4,\n 'default_params': [0.0, 1.0, 0.5, 0.001],\n 'hddm_include': ['z'],\n 'nchoices': 2}\n</code></pre> <p>Note: The usual structure of these models includes,</p> <ul> <li>Parameter names (<code>'params'</code>)</li> <li>Bounds on the parameters (<code>'param_bounds'</code>)</li> <li>A function that defines a boundary for the respective model (<code>'boundary'</code>)</li> <li>The number of parameters (<code>'n_params'</code>)</li> <li>Defaults for the parameters (<code>'default_params'</code>)</li> <li>The number of choices the process can produce (<code>'nchoices'</code>)</li> </ul> <p>The <code>'hddm_include'</code> key concerns information useful for integration with the hddm python package, which facilitates hierarchical bayesian inference for sequential sampling models. It is not important for the present tutorial.</p> <pre><code>from ssms.basic_simulators import simulator\nsim_out = simulator(model = 'ddm', \n                    theta = [0, 1, 0.5, 0.5],\n                    n_samples = 1000)\n</code></pre> <p>The output of the simulator is a <code>dictionary</code> with three elements.</p> <ol> <li><code>rts</code> (array)</li> <li><code>choices</code> (array)</li> <li><code>metadata</code> (dictionary)</li> </ol> <p>The <code>metadata</code> includes the named parameters, simulator settings, and more.</p>"},{"location":"#using-the-training-data-generators","title":"Using the Training Data Generators","text":"<p>The training data generators sit on top of the simulator function to turn raw simulations into usable training data for training machine learning algorithms aimed at posterior or likelihood armortization.</p> <p>We will use the <code>data_generator</code> class from <code>ssms.dataset_generators</code>. Initializing the <code>data_generator</code> boils down to supplying two configuration dictionaries.</p> <ol> <li>The <code>generator_config</code>, concerns choices as to what kind of training data one wants to generate.</li> <li>The <code>model_config</code> concerns choices with respect to the underlying generative sequential sampling model. </li> </ol> <p>We will consider a basic example here, concerning data generation to prepare for training LANs.</p> <p>Let's start by peeking at an example <code>generator_config</code>.</p> <pre><code>ssms.config.data_generator_config['lan']['mlp']\n</code></pre> <pre><code>{'output_folder': 'data/lan_mlp/',\n 'dgp_list': 'ddm',\n 'nbins': 0,\n 'n_samples': 100000,\n 'n_parameter_sets': 10000,\n 'n_parameter_sets_rejected': 100,\n 'n_training_samples_by_parameter_set': 1000,\n 'max_t': 20.0,\n 'delta_t': 0.001,\n 'pickleprotocol': 4,\n 'n_cpus': 'all',\n 'kde_data_mixture_probabilities': [0.8, 0.1, 0.1],\n 'simulation_filters': {'mode': 20,\n  'choice_cnt': 0,\n  'mean_rt': 17,\n  'std': 0,\n  'mode_cnt_rel': 0.9},\n 'negative_rt_cutoff': -66.77497,\n 'n_subruns': 10,\n 'bin_pointwise': False,\n 'separate_response_channels': False}\n</code></pre> <p>You usually have to make just few changes to this basic configuration dictionary. An example below.</p> <pre><code>from copy import deepcopy\n# Initialize the generator config (for MLP LANs)\ngenerator_config = deepcopy(ssms.config.data_generator_config['lan']['mlp'])\n# Specify generative model (one from the list of included models mentioned above)\ngenerator_config['dgp_list'] = 'angle' \n# Specify number of parameter sets to simulate\ngenerator_config['n_parameter_sets'] = 100 \n# Specify how many samples a simulation run should entail\ngenerator_config['n_samples'] = 1000\n</code></pre> <p>Now let's define our corresponding <code>model_config</code>.</p> <pre><code>model_config = ssms.config.model_config['angle']\nprint(model_config)\n</code></pre> <pre><code>{'name': 'angle', 'params': ['v', 'a', 'z', 't', 'theta'], 'param_bounds': [[-3.0, 0.3, 0.1, 0.001, -0.1], [3.0, 3.0, 0.9, 2.0, 1.3]], 'boundary': &lt;function angle at 0x11b2a7c10&gt;, 'n_params': 5, 'default_params': [0.0, 1.0, 0.5, 0.001, 0.0], 'hddm_include': ['z', 'theta'], 'nchoices': 2}\n</code></pre> <p>We are now ready to initialize a <code>data_generator</code>, after which we can generate training data using the <code>generate_data_training_uniform</code> function, which will use the hypercube defined by our parameter bounds from the <code>model_config</code> to uniformly generate parameter sets and corresponding simulated datasets.</p> <pre><code>my_dataset_generator = ssms.dataset_generators.data_generator(generator_config = generator_config,\n                                                              model_config = model_config)\n</code></pre> <pre><code>n_cpus used:  6\nchecking:  data/lan_mlp/\n</code></pre> <pre><code>training_data = my_dataset_generator.generate_data_training_uniform(save = False)\n</code></pre> <pre><code>simulation round: 1  of 10\nsimulation round: 2  of 10\nsimulation round: 3  of 10\nsimulation round: 4  of 10\nsimulation round: 5  of 10\nsimulation round: 6  of 10\nsimulation round: 7  of 10\nsimulation round: 8  of 10\nsimulation round: 9  of 10\nsimulation round: 10  of 10\n</code></pre> <p><code>training_data</code> is a dictionary containing four keys:</p> <ol> <li><code>data</code> the features for LANs, containing vectors of model parameters, as well as rts and choices.</li> <li><code>labels</code> which contain approximate likelihood values</li> <li><code>generator_config</code>, as defined above</li> <li><code>model_config</code>, as defined above</li> </ol> <p>You can now use this training data for your purposes. If you want to train LANs yourself, you might find the LANfactory package helpful.</p> <p>You may also simply find the basic simulators provided with the ssms package useful, without any desire to use the outputs into training data for amortization purposes.</p>"},{"location":"#end","title":"END","text":""},{"location":"api/basic_simulators/","title":"basic simulators","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions","title":"<code>boundary_functions</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle","title":"<code>angle(t=1, theta=1)</code>","text":"<p>angle boundary function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 1.\ntheta (float, optional): Angle in radians. Defaults to 1.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of boundary values, same shape as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma","title":"<code>conflict_gamma(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), theta=0.5, scale=1, alpha_gamma=1.01, scale_gamma=0.3)</code>","text":"<p>conflict bound that allows initial divergence then collapse</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma--arguments","title":"Arguments","text":"<pre><code>!!! t \"(float, np.ndarray)\"\n    Time points (with arbitrary measure, but in HDDM it is used as seconds),\n    at which to evaluate the bound. Defaults to np.arange(0, 20, 0.1).\n!!! theta \"float\"\n    Collapse angle. Defaults to 0.5.\n!!! scale \"float\"\n    Scaling the gamma distribution of the boundary\n    (since bound does not have to integrate to one). Defaults to 1.0.\n!!! alpha_gamma \"float\"\n    alpha parameter for a gamma in scale shape parameterization. Defaults to\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant","title":"<code>constant(t=0)</code>","text":"<p>constant boundary function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 0.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant--returns","title":"Returns","text":"<pre><code>float or np.ndarray: Constant boundary value(s), same shape as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic","title":"<code>generalized_logistic(t=1, B=2.0, M=3.0, v=0.5)</code>","text":"<p>generalized logistic bound</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 1.\nB (float, optional): Growth rate. Defaults to 2.0.\nM (float, optional): Time of maximum growth. Defaults to 3.0.\nv (float, optional): Affects near which asymptote maximum growth occurs. Defaults to 0.5.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of boundary values, same shape as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf","title":"<code>weibull_cdf(t=1, alpha=1, beta=1)</code>","text":"<p>boundary based on weibull survival function.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 1.\nalpha (float, optional): Shape parameter. Defaults to 1.\nbeta (float, optional): Scale parameter. Defaults to 1.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of boundary values, same shape as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions","title":"<code>drift_functions</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.attend_drift","title":"<code>attend_drift(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), p_target=-0.3, p_outer=-0.3, p_inner=0.3, r=0.5, sda=2)</code>","text":"<p>Drift function for shrinking spotlight model, which involves a time varying function dependent on a linearly decreasing standard deviation of attention.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.attend_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! p_outer \"float\"\n    perceptual input for outer flankers\n!!! p_inner \"float\"\n    perceptual input for inner flankers\n!!! p_target \"float\"\n    perceptual input for target flanker\n!!! r \"float\"\n    rate parameter for sda decrease\n!!! sda \"float\"\n    width of attentional spotlight\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.attend_drift--return","title":"Return","text":"<p>np.ndarray     Drift evaluated at timepoints t</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant","title":"<code>constant(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]))</code>","text":"<p>constant drift function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray, optional\"\n    Timepoints at which to evaluate the drift. Defaults to np.arange(0, 20, 0.1).\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of drift values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift","title":"<code>ds_conflict_drift(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), tinit=0, dinit=0, tslope=1, dslope=1, tfixedp=1, tcoh=1.5, dcoh=1.5)</code>","text":"<p>This drift is inspired by a conflict task which    involves a target and a distractor stimuli both presented    simultaneously.    Two drift timecourses are linearly combined weighted    by the coherence in the respective target and distractor stimuli.    Each timecourse follows a dynamical system as described    in the ds_support_analytic() function.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! tinit \"float\"\n    Initial condition of target drift timecourse\n!!! dinit \"float\"\n    Initial condition of distractor drift timecourse\n!!! tslope \"float\"\n    Slope parameter for target drift timecourse\n!!! dslope \"float\"\n    Slope parameter for distractor drift timecourse\n!!! tfixedp \"float\"\n    Fixed point for target drift timecourse\n!!! tcoh \"float\"\n    Coefficient for the target drift timecourse\n!!! dcoh \"float\"\n    Coefficient for the distractor drift timecourse\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift--return","title":"Return","text":"<p>np.ndarray      The full drift timecourse evaluated at the supplied timepoints t.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic","title":"<code>ds_support_analytic(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), init_p=0, fix_point=1, slope=2)</code>","text":"<p>Solution to differential equation of the form:    x' = slope*(fix_point - x),    with initial condition init_p.    The solution takes the form:    (init_p - fix_point) * exp(-slope * t) + fix_point</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift. Usually np.arange() of some sort.\n!!! init_p \"float\"\n    Initial condition of dynamical system\n!!! fix_point \"float\"\n    Fixed point of dynamical system\n!!! slope \"float\"\n    Coefficient in exponent of the solution.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic--return","title":"Return","text":"<p>np.ndarray      The gamma drift evaluated at the supplied timepoints t.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift","title":"<code>gamma_drift(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), shape=2, scale=0.01, c=1.5)</code>","text":"<p>Drift function that follows a scaled gamma distribution</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! shape \"float\"\n    Shape parameter of the gamma distribution\n!!! scale \"float\"\n    Scale parameter of the gamma distribution\n!!! c \"float\"\n    Scalar parameter that scales the peak of\n    the gamma distribution.\n    (Note this function follows a gamma distribution\n    but does not integrate to 1)\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift--return","title":"Return","text":"<pre><code>np.ndarray\n    The gamma drift evaluated at the supplied timepoints t.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator","title":"<code>simulator</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_arbitrary_fptd","title":"<code>bin_arbitrary_fptd(out=None, bin_dt=0.04, nbins=256, nchoices=2, choice_codes=[-1.0, 1.0], max_t=10.0)</code>","text":"<p>Takes in simulator output and returns a histogram of bin counts Arguments</p> <pre><code>!!! out \"np.ndarray\"\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired bin size\n    which in turn automatically determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\n!!! nchoices \"int &lt;default=2&gt;\"\n    Number of choices allowed by the simulator.\nchoice_codes = list[float] &lt;default=[-1.0, 1.0]&gt;\n    Choice labels to be used.\n!!! max_t \"float\"\n    Maximum RT to consider.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_arbitrary_fptd--returns","title":"Returns","text":"<pre><code>2d array (nbins, nchoices): A histogram of bin counts\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output","title":"<code>bin_simulator_output(out=None, bin_dt=0.04, nbins=0, max_t=-1, freq_cnt=False)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output--arguments","title":"Arguments","text":"<pre><code>out : dict\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nmax_t : float &lt;default=-1&gt;\n    Override the 'max_t' metadata as part of the simulator output.\n    Sometimes useful, but usually default will do the job.\nfreq_cnt : bool &lt;default=False&gt;\n    Decide whether to return proportions (default) or counts in bins.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output--returns","title":"Returns","text":"<pre><code>A histogram of counts or proportions.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise","title":"<code>bin_simulator_output_pointwise(out=(array([0]), array([0])), bin_dt=0.04, nbins=0)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--arguments","title":"Arguments","text":"<pre><code>!!! out \"tuple\"\n    Output of the 'simulator' function\n!!! bin_dt \"float\"\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\n!!! nbins \"int\"\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the\n    number of bins automatically.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--returns","title":"Returns","text":"<pre><code>2d array. The first columns collects bin-identifiers\nby trial, the second column lists the corresponding choices.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.make_boundary_dict","title":"<code>make_boundary_dict(config, theta)</code>","text":"<p>Create a dictionary containing boundary-related parameters and functions.</p> <p>This function extracts boundary-related parameters from the input theta dictionary, based on the boundary configuration specified in the config. It also retrieves the appropriate boundary function and multiplicative flag from the boundary_config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A dictionary containing model configuration, including the boundary name.</p> required <code>theta</code> <code>dict</code> <p>A dictionary of parameter values, potentially including boundary-related parameters.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing:     - boundary_params (dict): Extracted boundary-related parameters.     - boundary_fun (callable): The boundary function corresponding to the specified boundary name.     - boundary_multiplicative (bool): Flag indicating if the boundary is multiplicative.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.make_drift_dict","title":"<code>make_drift_dict(config, theta)</code>","text":"<p>Create a dictionary containing drift-related parameters and functions.</p> <p>This function extracts drift-related parameters from the input theta dictionary, based on the drift configuration specified in the config. It also retrieves the appropriate drift function from the drift_config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A dictionary containing model configuration, including the drift name.</p> required <code>theta</code> <code>dict</code> <p>A dictionary of parameter values, potentially including drift-related parameters.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing:     - drift_fun (callable): The drift function corresponding to the specified drift name.     - drift_params (dict): Extracted drift-related parameters.     If no drift name is specified in config, returns an empty dictionary.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator","title":"<code>simulator(theta, model='angle', n_samples=1000, delta_t=0.001, max_t=20, no_noise=False, bin_dim=None, bin_pointwise=False, sigma_noise=None, smooth_unif=True, return_option='full', random_state=None)</code>","text":"<p>Basic data simulator for the models included in HDDM.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator--arguments","title":"Arguments","text":"<pre><code>theta : list, numpy.array, dict or pd.DataFrame\n    Parameters of the simulator. If 2d array, each row is treated as a 'trial'\n    and the function runs n_sample * n_trials simulations.\ndeadline : numpy.array &lt;default=None&gt;\n    If supplied, the simulator will run a deadline model. RTs will be returned\n!!! model \"str &lt;default='angle'&gt;\"\n    Determines the model that will be simulated.\n!!! n_samples \"int &lt;default=1000&gt;\"\n    Number of simulation runs for each row in the theta argument.\n!!! delta_t \"float\"\n    Size fo timesteps in simulator (conceptually measured in seconds)\n!!! max_t \"float\"\n    Maximum reaction the simulator can reach\n!!! no_noise \"bool &lt;default=False&gt;\"\n    Turn noise of (useful for plotting purposes mostly)\n!!! bin_dim \"int | None &lt;default=None&gt;\"\n    Number of bins to use (in case the simulator output is\n    supposed to come out as a count histogram)\n!!! bin_pointwise \"bool &lt;default=False&gt;\"\n    Wheter or not to bin the output data pointwise.\n    If true the 'RT' part of the data is now specifies the\n    'bin-number' of a given trial instead of the 'RT' directly.\n    You need to specify bin_dim as some number for this to work.\n!!! sigma_noise \"float | None &lt;default=None&gt;\"\n    Standard deviation of noise in the diffusion process. If None, defaults to 1.0 for most models\n    and 0.1 for LBA models. If no_noise is True, sigma_noise will be set to 0.0.\n    If 'sd' or 's' is passed via theta dictionary, sigma_noise must be None.\n!!! smooth_unif \"bool &lt;default=True&gt;\"\n    Whether to add uniform random noise to RTs to smooth the distributions.\n!!! return_option \"str &lt;default='full'&gt;\"\n    Determines what the function returns. Can be either\n    'full' or 'minimal'. If 'full' the function returns\n    a dictionary with keys 'rts', 'responses' and 'metadata', and\n    metadata contains the model parameters and some additional\n    information. 'metadata' is a simpler dictionary with less information\n    if 'minimal' is chosen.\n!!! random_state \"int | None &lt;default=None&gt;\"\n    Integer passed to random_seed function in the simulator.\n    Can be used for reproducibility.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator--return","title":"Return","text":"<p>dictionary where keys     can be (rts, responses, metadata)     or     (rt-response histogram, metadata)     or     (rts binned pointwise, responses, metadata)</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.validate_ssm_parameters","title":"<code>validate_ssm_parameters(model, theta)</code>","text":"<p>Validate the parameters for Sequential Sampling Models (SSM).</p> <p>This function checks the validity of parameters for different SSM models. It performs specific checks based on the model type.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the SSM model.</p> required <code>theta</code> <code>dict</code> <p>A dictionary containing the model parameters.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If any of the parameter validations fail.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.theta_processor","title":"<code>theta_processor</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.theta_processor.AbstractThetaProcessor","title":"<code> AbstractThetaProcessor            (ABC)         </code>","text":"<p>Abstract base class for theta processors.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.theta_processor.AbstractThetaProcessor.process_theta","title":"<code>process_theta(self, theta, model_config, n_trials)</code>","text":"<p>Abstract method to process theta parameters.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Dict[str, Any]</code> <p>Dictionary of theta parameters.</p> required <code>model_config</code> <code>Dict[str, Any]</code> <p>Dictionary of model configuration.</p> required <code>n_trials</code> <code>int</code> <p>Number of trials.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Processed theta parameters.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.theta_processor.SimpleThetaProcessor","title":"<code> SimpleThetaProcessor            (AbstractThetaProcessor)         </code>","text":"<p>A simple implementation of the AbstractThetaProcessor. This class collects functions (for now very simple) that build the bridge between the model_config level specification of the model and the theta parameters that are used in the simulator.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.theta_processor.SimpleThetaProcessor.process_theta","title":"<code>process_theta(self, theta, model_config, n_trials)</code>","text":"<p>Process theta parameters based on the model configuration.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Dict[str, Any]</code> <p>Dictionary of theta parameters.</p> required <code>model_config</code> <code>Dict[str, Any]</code> <p>Dictionary of model configuration.</p> required <code>n_trials</code> <code>int</code> <p>Number of trials.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Processed theta parameters.</p>"},{"location":"api/config/","title":"config","text":""},{"location":"api/config/#ssms.config.config","title":"<code>config</code>","text":""},{"location":"api/config/#ssms.config.config.boundary_config_to_function_params","title":"<code>boundary_config_to_function_params(boundary_config)</code>","text":"<p>Convert boundary configuration to function parameters</p> <p>dict</p> <p>Dictionary containing the boundary configuration</p> <p>dict     Dictionary with adjusted key names so that they match function parameters names     directly.</p>"},{"location":"api/dataset_generators/","title":"data generators","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp","title":"<code>lan_mlp</code>","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator","title":"<code> data_generator        </code>","text":"<p>The data_generator() class is used to generate training data   for various likelihood approximators.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator--attributes","title":"Attributes","text":"<pre><code>!!! generator_config \"dict\"\n    Configuation dictionary for the data generator.\n    (For an example load ssms.config.data_generator_config['lan'])\n!!! model_config \"dict\"\n    Configuration dictionary for the model to be simulated.\n    (For an example load ssms.config.model_config['ddm'])\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator--methods","title":"Methods","text":"<pre><code>generate_data_training_uniform(save=False, verbose=True, cpn_only=False)\n    Generates training data for LANs.\nget_simulations(theta=None, random_seed=None)\n    Generates simulations for a given parameter set.\n_filter_simulations(simulations=None)\n    Filters simulations according to the criteria\n    specified in the generator_config.\n_make_kde_data(simulations=None, theta=None)\n    Generates KDE data from simulations.\n_mlp_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for MLPs.\n_cpn_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for CPNs.\n_get_rejected_parameter_setups(random_seed_tuple)\n    Helper function that collectes parameters sets which were rejected\n    by the filter used in the _filter_simulations() method.\n_make_save_file_name(unique_tag=None)\n    Helper function for generating save file names.\n_build_simulator()\n    Builds simulator function for LANs.\n_get_ncpus()\n    Helper function for determining the number of\n    cpus to use for parallelization.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator--returns","title":"Returns","text":"<pre><code>data_generator object\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.__init__","title":"<code>__init__(self, generator_config=None, model_config=None)</code>  <code>special</code>","text":"<p>Initialize data generator class.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.__init__--arguments","title":"Arguments","text":"<p>dict</p> <p>Configuration dictionary for the data generator. (For an example load ssms.config.data_generator_config['lan'])</p> <p>dict</p> <p>Configuration dictionary for the model to be simulated. (For an example load ssms.config.model_config['ddm'])</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.__init__--raises","title":"Raises","text":"<p>ValueError     If no generator_config or model_config is specified.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.__init__--returns","title":"Returns","text":"<p>data_generator object</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False, verbose=True, cpn_only=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_rejected_parameterizations","title":"<code>generate_rejected_parameterizations(self, save=False)</code>","text":"<p>Generates parameterizations that are rejected by the filter.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_rejected_parameterizations--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_rejected_parameterizations--returns","title":"Returns","text":"<pre><code>!!! rejected_parameterization_list \"np.array\"\n    Array containing the rejected parameterizations.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.get_simulations","title":"<code>get_simulations(self, theta=None, random_seed=None)</code>","text":"<p>Generates simulations for a given parameter set.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.parameter_transform_for_data_gen","title":"<code>parameter_transform_for_data_gen(self, theta)</code>","text":"<p>Function to impose constraints on the parameters for data generation.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.parameter_transform_for_data_gen--arguments","title":"Arguments","text":"<pre><code>!!! theta \"dict\"\n    Dictionary containing the parameters.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.parameter_transform_for_data_gen--returns","title":"Returns","text":"<pre><code>!!! theta \"dict\"\n    Dictionary containing the transformed parameters.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe","title":"<code>snpe</code>","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe","title":"<code> data_generator_snpe            (data_generator)         </code>","text":"<p>Class for generating data for SNPE.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe--attributes","title":"Attributes","text":"<p>dict</p> <p>Configuration for data generation</p> <p>dict</p> <p>Configuration for model</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe--methods","title":"Methods","text":"<p>generate_data_training_uniform(save=False)     Generates data for training SNPE. _snpe_get_processed_data_for_theta(random_seed)     Helper function for generating data for SNPE. _build_simulator()     Builds simulator function for SNPE.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/ssms/","title":"ssms","text":""},{"location":"api/ssms/#ssms.basic_simulators","title":"<code>basic_simulators</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions","title":"<code>boundary_functions</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle","title":"<code>angle(t=1, theta=1)</code>","text":"<p>angle boundary function</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 1.\ntheta (float, optional): Angle in radians. Defaults to 1.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of boundary values, same shape as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma","title":"<code>conflict_gamma(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), theta=0.5, scale=1, alpha_gamma=1.01, scale_gamma=0.3)</code>","text":"<p>conflict bound that allows initial divergence then collapse</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma--arguments","title":"Arguments","text":"<pre><code>!!! t \"(float, np.ndarray)\"\n    Time points (with arbitrary measure, but in HDDM it is used as seconds),\n    at which to evaluate the bound. Defaults to np.arange(0, 20, 0.1).\n!!! theta \"float\"\n    Collapse angle. Defaults to 0.5.\n!!! scale \"float\"\n    Scaling the gamma distribution of the boundary\n    (since bound does not have to integrate to one). Defaults to 1.0.\n!!! alpha_gamma \"float\"\n    alpha parameter for a gamma in scale shape parameterization. Defaults to\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant","title":"<code>constant(t=0)</code>","text":"<p>constant boundary function</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 0.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant--returns","title":"Returns","text":"<pre><code>float or np.ndarray: Constant boundary value(s), same shape as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic","title":"<code>generalized_logistic(t=1, B=2.0, M=3.0, v=0.5)</code>","text":"<p>generalized logistic bound</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 1.\nB (float, optional): Growth rate. Defaults to 2.0.\nM (float, optional): Time of maximum growth. Defaults to 3.0.\nv (float, optional): Affects near which asymptote maximum growth occurs. Defaults to 0.5.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of boundary values, same shape as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf","title":"<code>weibull_cdf(t=1, alpha=1, beta=1)</code>","text":"<p>boundary based on weibull survival function.</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf--arguments","title":"Arguments","text":"<pre><code>t (float or np.ndarray, optional): Time point(s). Defaults to 1.\nalpha (float, optional): Shape parameter. Defaults to 1.\nbeta (float, optional): Scale parameter. Defaults to 1.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of boundary values, same shape as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions","title":"<code>drift_functions</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.attend_drift","title":"<code>attend_drift(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), p_target=-0.3, p_outer=-0.3, p_inner=0.3, r=0.5, sda=2)</code>","text":"<p>Drift function for shrinking spotlight model, which involves a time varying function dependent on a linearly decreasing standard deviation of attention.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.attend_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! p_outer \"float\"\n    perceptual input for outer flankers\n!!! p_inner \"float\"\n    perceptual input for inner flankers\n!!! p_target \"float\"\n    perceptual input for target flanker\n!!! r \"float\"\n    rate parameter for sda decrease\n!!! sda \"float\"\n    width of attentional spotlight\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.attend_drift--return","title":"Return","text":"<p>np.ndarray     Drift evaluated at timepoints t</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant","title":"<code>constant(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]))</code>","text":"<p>constant drift function</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray, optional\"\n    Timepoints at which to evaluate the drift. Defaults to np.arange(0, 20, 0.1).\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant--returns","title":"Returns","text":"<pre><code>np.ndarray: Array of drift values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift","title":"<code>ds_conflict_drift(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), tinit=0, dinit=0, tslope=1, dslope=1, tfixedp=1, tcoh=1.5, dcoh=1.5)</code>","text":"<p>This drift is inspired by a conflict task which    involves a target and a distractor stimuli both presented    simultaneously.    Two drift timecourses are linearly combined weighted    by the coherence in the respective target and distractor stimuli.    Each timecourse follows a dynamical system as described    in the ds_support_analytic() function.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! tinit \"float\"\n    Initial condition of target drift timecourse\n!!! dinit \"float\"\n    Initial condition of distractor drift timecourse\n!!! tslope \"float\"\n    Slope parameter for target drift timecourse\n!!! dslope \"float\"\n    Slope parameter for distractor drift timecourse\n!!! tfixedp \"float\"\n    Fixed point for target drift timecourse\n!!! tcoh \"float\"\n    Coefficient for the target drift timecourse\n!!! dcoh \"float\"\n    Coefficient for the distractor drift timecourse\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift--return","title":"Return","text":"<p>np.ndarray      The full drift timecourse evaluated at the supplied timepoints t.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic","title":"<code>ds_support_analytic(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), init_p=0, fix_point=1, slope=2)</code>","text":"<p>Solution to differential equation of the form:    x' = slope*(fix_point - x),    with initial condition init_p.    The solution takes the form:    (init_p - fix_point) * exp(-slope * t) + fix_point</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift. Usually np.arange() of some sort.\n!!! init_p \"float\"\n    Initial condition of dynamical system\n!!! fix_point \"float\"\n    Fixed point of dynamical system\n!!! slope \"float\"\n    Coefficient in exponent of the solution.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic--return","title":"Return","text":"<p>np.ndarray      The gamma drift evaluated at the supplied timepoints t.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift","title":"<code>gamma_drift(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), shape=2, scale=0.01, c=1.5)</code>","text":"<p>Drift function that follows a scaled gamma distribution</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! shape \"float\"\n    Shape parameter of the gamma distribution\n!!! scale \"float\"\n    Scale parameter of the gamma distribution\n!!! c \"float\"\n    Scalar parameter that scales the peak of\n    the gamma distribution.\n    (Note this function follows a gamma distribution\n    but does not integrate to 1)\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift--return","title":"Return","text":"<pre><code>np.ndarray\n    The gamma drift evaluated at the supplied timepoints t.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator","title":"<code>simulator</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_arbitrary_fptd","title":"<code>bin_arbitrary_fptd(out=None, bin_dt=0.04, nbins=256, nchoices=2, choice_codes=[-1.0, 1.0], max_t=10.0)</code>","text":"<p>Takes in simulator output and returns a histogram of bin counts Arguments</p> <pre><code>!!! out \"np.ndarray\"\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired bin size\n    which in turn automatically determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\n!!! nchoices \"int &lt;default=2&gt;\"\n    Number of choices allowed by the simulator.\nchoice_codes = list[float] &lt;default=[-1.0, 1.0]&gt;\n    Choice labels to be used.\n!!! max_t \"float\"\n    Maximum RT to consider.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_arbitrary_fptd--returns","title":"Returns","text":"<pre><code>2d array (nbins, nchoices): A histogram of bin counts\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output","title":"<code>bin_simulator_output(out=None, bin_dt=0.04, nbins=0, max_t=-1, freq_cnt=False)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output--arguments","title":"Arguments","text":"<pre><code>out : dict\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nmax_t : float &lt;default=-1&gt;\n    Override the 'max_t' metadata as part of the simulator output.\n    Sometimes useful, but usually default will do the job.\nfreq_cnt : bool &lt;default=False&gt;\n    Decide whether to return proportions (default) or counts in bins.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output--returns","title":"Returns","text":"<pre><code>A histogram of counts or proportions.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise","title":"<code>bin_simulator_output_pointwise(out=(array([0]), array([0])), bin_dt=0.04, nbins=0)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--arguments","title":"Arguments","text":"<pre><code>!!! out \"tuple\"\n    Output of the 'simulator' function\n!!! bin_dt \"float\"\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\n!!! nbins \"int\"\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the\n    number of bins automatically.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--returns","title":"Returns","text":"<pre><code>2d array. The first columns collects bin-identifiers\nby trial, the second column lists the corresponding choices.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.make_boundary_dict","title":"<code>make_boundary_dict(config, theta)</code>","text":"<p>Create a dictionary containing boundary-related parameters and functions.</p> <p>This function extracts boundary-related parameters from the input theta dictionary, based on the boundary configuration specified in the config. It also retrieves the appropriate boundary function and multiplicative flag from the boundary_config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A dictionary containing model configuration, including the boundary name.</p> required <code>theta</code> <code>dict</code> <p>A dictionary of parameter values, potentially including boundary-related parameters.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing:     - boundary_params (dict): Extracted boundary-related parameters.     - boundary_fun (callable): The boundary function corresponding to the specified boundary name.     - boundary_multiplicative (bool): Flag indicating if the boundary is multiplicative.</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.make_drift_dict","title":"<code>make_drift_dict(config, theta)</code>","text":"<p>Create a dictionary containing drift-related parameters and functions.</p> <p>This function extracts drift-related parameters from the input theta dictionary, based on the drift configuration specified in the config. It also retrieves the appropriate drift function from the drift_config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A dictionary containing model configuration, including the drift name.</p> required <code>theta</code> <code>dict</code> <p>A dictionary of parameter values, potentially including drift-related parameters.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing:     - drift_fun (callable): The drift function corresponding to the specified drift name.     - drift_params (dict): Extracted drift-related parameters.     If no drift name is specified in config, returns an empty dictionary.</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator","title":"<code>simulator(theta, model='angle', n_samples=1000, delta_t=0.001, max_t=20, no_noise=False, bin_dim=None, bin_pointwise=False, sigma_noise=None, smooth_unif=True, return_option='full', random_state=None)</code>","text":"<p>Basic data simulator for the models included in HDDM.</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator--arguments","title":"Arguments","text":"<pre><code>theta : list, numpy.array, dict or pd.DataFrame\n    Parameters of the simulator. If 2d array, each row is treated as a 'trial'\n    and the function runs n_sample * n_trials simulations.\ndeadline : numpy.array &lt;default=None&gt;\n    If supplied, the simulator will run a deadline model. RTs will be returned\n!!! model \"str &lt;default='angle'&gt;\"\n    Determines the model that will be simulated.\n!!! n_samples \"int &lt;default=1000&gt;\"\n    Number of simulation runs for each row in the theta argument.\n!!! delta_t \"float\"\n    Size fo timesteps in simulator (conceptually measured in seconds)\n!!! max_t \"float\"\n    Maximum reaction the simulator can reach\n!!! no_noise \"bool &lt;default=False&gt;\"\n    Turn noise of (useful for plotting purposes mostly)\n!!! bin_dim \"int | None &lt;default=None&gt;\"\n    Number of bins to use (in case the simulator output is\n    supposed to come out as a count histogram)\n!!! bin_pointwise \"bool &lt;default=False&gt;\"\n    Wheter or not to bin the output data pointwise.\n    If true the 'RT' part of the data is now specifies the\n    'bin-number' of a given trial instead of the 'RT' directly.\n    You need to specify bin_dim as some number for this to work.\n!!! sigma_noise \"float | None &lt;default=None&gt;\"\n    Standard deviation of noise in the diffusion process. If None, defaults to 1.0 for most models\n    and 0.1 for LBA models. If no_noise is True, sigma_noise will be set to 0.0.\n    If 'sd' or 's' is passed via theta dictionary, sigma_noise must be None.\n!!! smooth_unif \"bool &lt;default=True&gt;\"\n    Whether to add uniform random noise to RTs to smooth the distributions.\n!!! return_option \"str &lt;default='full'&gt;\"\n    Determines what the function returns. Can be either\n    'full' or 'minimal'. If 'full' the function returns\n    a dictionary with keys 'rts', 'responses' and 'metadata', and\n    metadata contains the model parameters and some additional\n    information. 'metadata' is a simpler dictionary with less information\n    if 'minimal' is chosen.\n!!! random_state \"int | None &lt;default=None&gt;\"\n    Integer passed to random_seed function in the simulator.\n    Can be used for reproducibility.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator--return","title":"Return","text":"<p>dictionary where keys     can be (rts, responses, metadata)     or     (rt-response histogram, metadata)     or     (rts binned pointwise, responses, metadata)</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.validate_ssm_parameters","title":"<code>validate_ssm_parameters(model, theta)</code>","text":"<p>Validate the parameters for Sequential Sampling Models (SSM).</p> <p>This function checks the validity of parameters for different SSM models. It performs specific checks based on the model type.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the SSM model.</p> required <code>theta</code> <code>dict</code> <p>A dictionary containing the model parameters.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If any of the parameter validations fail.</p>"},{"location":"api/ssms/#ssms.basic_simulators.theta_processor","title":"<code>theta_processor</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.theta_processor.AbstractThetaProcessor","title":"<code> AbstractThetaProcessor            (ABC)         </code>","text":"<p>Abstract base class for theta processors.</p>"},{"location":"api/ssms/#ssms.basic_simulators.theta_processor.AbstractThetaProcessor.process_theta","title":"<code>process_theta(self, theta, model_config, n_trials)</code>","text":"<p>Abstract method to process theta parameters.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Dict[str, Any]</code> <p>Dictionary of theta parameters.</p> required <code>model_config</code> <code>Dict[str, Any]</code> <p>Dictionary of model configuration.</p> required <code>n_trials</code> <code>int</code> <p>Number of trials.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Processed theta parameters.</p>"},{"location":"api/ssms/#ssms.basic_simulators.theta_processor.SimpleThetaProcessor","title":"<code> SimpleThetaProcessor            (AbstractThetaProcessor)         </code>","text":"<p>A simple implementation of the AbstractThetaProcessor. This class collects functions (for now very simple) that build the bridge between the model_config level specification of the model and the theta parameters that are used in the simulator.</p>"},{"location":"api/ssms/#ssms.basic_simulators.theta_processor.SimpleThetaProcessor.process_theta","title":"<code>process_theta(self, theta, model_config, n_trials)</code>","text":"<p>Process theta parameters based on the model configuration.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Dict[str, Any]</code> <p>Dictionary of theta parameters.</p> required <code>model_config</code> <code>Dict[str, Any]</code> <p>Dictionary of model configuration.</p> required <code>n_trials</code> <code>int</code> <p>Number of trials.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Processed theta parameters.</p>"},{"location":"api/ssms/#ssms.config","title":"<code>config</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.config.config","title":"<code>config</code>","text":""},{"location":"api/ssms/#ssms.config.config.boundary_config_to_function_params","title":"<code>boundary_config_to_function_params(boundary_config)</code>","text":"<p>Convert boundary configuration to function parameters</p> <p>dict</p> <p>Dictionary containing the boundary configuration</p> <p>dict     Dictionary with adjusted key names so that they match function parameters names     directly.</p>"},{"location":"api/ssms/#ssms.dataset_generators","title":"<code>dataset_generators</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp","title":"<code>lan_mlp</code>","text":""},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator","title":"<code> data_generator        </code>","text":"<p>The data_generator() class is used to generate training data   for various likelihood approximators.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator--attributes","title":"Attributes","text":"<pre><code>!!! generator_config \"dict\"\n    Configuation dictionary for the data generator.\n    (For an example load ssms.config.data_generator_config['lan'])\n!!! model_config \"dict\"\n    Configuration dictionary for the model to be simulated.\n    (For an example load ssms.config.model_config['ddm'])\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator--methods","title":"Methods","text":"<pre><code>generate_data_training_uniform(save=False, verbose=True, cpn_only=False)\n    Generates training data for LANs.\nget_simulations(theta=None, random_seed=None)\n    Generates simulations for a given parameter set.\n_filter_simulations(simulations=None)\n    Filters simulations according to the criteria\n    specified in the generator_config.\n_make_kde_data(simulations=None, theta=None)\n    Generates KDE data from simulations.\n_mlp_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for MLPs.\n_cpn_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for CPNs.\n_get_rejected_parameter_setups(random_seed_tuple)\n    Helper function that collectes parameters sets which were rejected\n    by the filter used in the _filter_simulations() method.\n_make_save_file_name(unique_tag=None)\n    Helper function for generating save file names.\n_build_simulator()\n    Builds simulator function for LANs.\n_get_ncpus()\n    Helper function for determining the number of\n    cpus to use for parallelization.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator--returns","title":"Returns","text":"<pre><code>data_generator object\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.__init__","title":"<code>__init__(self, generator_config=None, model_config=None)</code>  <code>special</code>","text":"<p>Initialize data generator class.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.__init__--arguments","title":"Arguments","text":"<p>dict</p> <p>Configuration dictionary for the data generator. (For an example load ssms.config.data_generator_config['lan'])</p> <p>dict</p> <p>Configuration dictionary for the model to be simulated. (For an example load ssms.config.model_config['ddm'])</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.__init__--raises","title":"Raises","text":"<p>ValueError     If no generator_config or model_config is specified.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.__init__--returns","title":"Returns","text":"<p>data_generator object</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False, verbose=True, cpn_only=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_rejected_parameterizations","title":"<code>generate_rejected_parameterizations(self, save=False)</code>","text":"<p>Generates parameterizations that are rejected by the filter.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_rejected_parameterizations--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_rejected_parameterizations--returns","title":"Returns","text":"<pre><code>!!! rejected_parameterization_list \"np.array\"\n    Array containing the rejected parameterizations.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.get_simulations","title":"<code>get_simulations(self, theta=None, random_seed=None)</code>","text":"<p>Generates simulations for a given parameter set.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.parameter_transform_for_data_gen","title":"<code>parameter_transform_for_data_gen(self, theta)</code>","text":"<p>Function to impose constraints on the parameters for data generation.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.parameter_transform_for_data_gen--arguments","title":"Arguments","text":"<pre><code>!!! theta \"dict\"\n    Dictionary containing the parameters.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.parameter_transform_for_data_gen--returns","title":"Returns","text":"<pre><code>!!! theta \"dict\"\n    Dictionary containing the transformed parameters.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.snpe","title":"<code>snpe</code>","text":""},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe","title":"<code> data_generator_snpe            (data_generator)         </code>","text":"<p>Class for generating data for SNPE.</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe--attributes","title":"Attributes","text":"<p>dict</p> <p>Configuration for data generation</p> <p>dict</p> <p>Configuration for model</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe--methods","title":"Methods","text":"<p>generate_data_training_uniform(save=False)     Generates data for training SNPE. _snpe_get_processed_data_for_theta(random_seed)     Helper function for generating data for SNPE. _build_simulator()     Builds simulator function for SNPE.</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/ssms/#ssms.support_utils","title":"<code>support_utils</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.support_utils.kde_class","title":"<code>kde_class</code>","text":""},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE","title":"<code> LogKDE        </code>","text":"<p>Class for generating kdes from (rt, choice) data. Works for any number of choices.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE--attributes","title":"Attributes","text":"<pre><code>!!! simulator_data \"dict, default&lt;None\"\n    Dictionary of the type {'rts':[], 'choices':[], 'metadata':{}}.\n    Follows the format of simulator returns in this package.\n!!! bandwidth_type \"string\"\n    type of bandwidth to use, default is 'silverman'\n!!! auto_bandwidth \"boolean\"\n    whether to compute bandwidths automatically, default is True\n</code></pre>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE--methods","title":"Methods","text":"<pre><code>compute_bandwidths(type='silverman')\n    Computes bandwidths for each choice from rt data.\ngenerate_base_kdes(auto_bandwidth=True, bandwidth_type='silverman')\n    Generates kdes from rt data.\nkde_eval(data=([], []), log_eval=True)\n    Evaluates kde log likelihood at chosen points.\nkde_sample(n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)\n    Samples from a given kde.\nattach_data_from_simulator(simulator_data={'rts':[0, 2, 4], 'choices':[-1, 1, -1], 'metadata':{}}))\n    Helper function to transform ddm simulator output\n    to dataset suitable for the kde function class.\n</code></pre> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.attach_data_from_simulator","title":"<code>attach_data_from_simulator(self, simulator_data=([0, 2, 4], [-1, 1, -1]), filter_rts=-999)</code>","text":"<p>Helper function to transform ddm simulator output to dataset suitable for the kde function class.</p> <p>tuple</p> <p>Tuple of (rts, choices, simulator_info) as returned by simulator function.</p> <p>float</p> <p>Value to filter rts by, default is -999. -999 is the number returned by the simulators if we breach max_t or deadline.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.compute_bandwidths","title":"<code>compute_bandwidths(self, type='silverman')</code>","text":"<p>Computes bandwidths for each choice from rt data.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of bandwidths for each choice.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.generate_base_kdes","title":"<code>generate_base_kdes(self, auto_bandwidth=True, bandwidth_type='silverman')</code>","text":"<p>Generates kdes from rt data. We apply gaussian kernels to the log of the rts.</p> <p>boolean</p> <p>Whether to compute bandwidths automatically, default is True.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of kdes for each choice. (These get attached to the base_kdes attribute of the class, not returned)</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.kde_eval","title":"<code>kde_eval(self, data={}, log_eval=True, lb=-66.774, eps=0.0001, filter_rts=-999)</code>","text":"<p>Evaluates kde log likelihood at chosen points.</p> <p>dict</p> <p>Dictionary with keys 'rts', and/or 'log_rts' and 'choices' to evaluate the kde at. If 'rts' is provided, 'log_rts' is ignored.</p> <p>boolean</p> <p>Whether to return log likelihood or likelihood, default is True.</p> <p>float</p> <p>Lower bound for log likelihoods, default is -66.774. (This is the log of 1e-29)</p> <p>float</p> <p>Epsilon value to use for lower bounds on rts.</p> <p>float</p> <p>Value to filter rts by, default is -999. -999 is the number returned by the simulators if we breach max_t or deadline.</p> <p>array</p> <p>Array of log likelihoods for each (rt, choice) pair.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.kde_sample","title":"<code>kde_sample(self, n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)</code>","text":"<p>Samples from a given kde.</p> <p>int</p> <p>Number of samples to draw.</p> <p>boolean</p> <p>Whether to use empirical choice proportions, default is True. (Note 'empirical' here, refers to the originally attached datasets that served as the basis to generate the choice-wise kdes)</p> <p>array</p> <p>Array of choice proportions to use, default is 0. (Note 'alternate' here refers to 'alternative' to the 'empirical' choice proportions)</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.bandwidth_silverman","title":"<code>bandwidth_silverman(sample=[0, 0, 0], std_cutoff=0.001, std_proc='restrict', std_n_1=10)</code>","text":"<p>Computes silverman bandwidth for an array of samples (rts in our context, but general).</p> <p>array</p> <p>Array of samples to compute bandwidth for.</p> <p>float</p> <p>Cutoff for std, default is 1e-3. (If sample-std is smaller than this, we either kill it or restrict it to this value)</p> <p>string</p> <p>How to deal with small stds, default is 'restrict'. (Options: 'kill', 'restrict')</p> <p>float</p> <p>Value to use if n = 1, default is 10. (Not clear if the default is sensible here)</p> <p>float</p> <p>Silverman bandwidth for the given sample. This is applied as the bandwidth parameter when generating gaussian-based kdes in the LogKDE class.</p>"},{"location":"api/ssms/#ssms.support_utils.utils","title":"<code>utils</code>","text":""},{"location":"api/ssms/#ssms.support_utils.utils.build_dependency_graph","title":"<code>build_dependency_graph(param_dict)</code>","text":"<p>Build a dependency graph based on parameter bounds.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>Dict[str, Tuple[Any, Any]]</code> <p>A dictionary mapping parameter names to their bounds.</p> required <p>Returns:</p> Type Description <code>Dict[str, Set[str]]</code> <p>A dictionary representing the dependency graph where keys are parameter names,                      and values are sets of parameter names they depend on.</p>"},{"location":"api/ssms/#ssms.support_utils.utils.parse_bounds","title":"<code>parse_bounds(bounds)</code>","text":"<p>Parse the bounds of a parameter and extract any dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Tuple[Any, Any]</code> <p>A tuple containing the lower and upper bounds,                       which can be numeric or strings indicating dependencies.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of parameter names that the bounds depend on.</p>"},{"location":"api/ssms/#ssms.support_utils.utils.sample_parameters_from_constraints","title":"<code>sample_parameters_from_constraints(param_dict, sample_size)</code>","text":"<p>Sample parameters uniformly within specified bounds, respecting any dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>Dict[str, Tuple[Any, Any]]</code> <p>Dictionary mapping parameter names to their bounds.</p> required <code>sample_size</code> <code>int</code> <p>Number of samples to generate.</p> required <p>Returns:</p> Type Description <code>Dict[str, np.ndarray]</code> <p>A dictionary mapping parameter names to arrays of sampled values.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If dependencies cannot be resolved due to missing parameters or circular dependencies.</p>"},{"location":"api/ssms/#ssms.support_utils.utils.topological_sort","title":"<code>topological_sort(graph)</code>","text":"<p>Perform a topological sort on the dependency graph to determine the sampling order.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Dict[str, Set[str]]</code> <p>The dependency graph.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of parameter names in the order they should be sampled.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If a circular dependency is detected.</p>"},{"location":"api/ssms/#ssms.support_utils.utils.topological_sort_util","title":"<code>topological_sort_util(node, visited, stack, graph, temp_marks)</code>","text":"<p>Helper function for performing a depth-first search in the topological sort.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>The current node being visited.</p> required <code>visited</code> <code>Set[str]</code> <p>Set of nodes that have been permanently marked (fully processed).</p> required <code>stack</code> <code>List[str]</code> <p>List representing the ordering of nodes.</p> required <code>graph</code> <code>Dict[str, Set[str]]</code> <p>The dependency graph.</p> required <code>temp_marks</code> <code>Set[str]</code> <p>Set of nodes that have been temporarily marked (currently being processed).</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If a circular dependency is detected.</p>"},{"location":"api/support_utils/","title":"Support utils","text":""},{"location":"api/support_utils/#ssms.support_utils.kde_class","title":"<code>kde_class</code>","text":""},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE","title":"<code> LogKDE        </code>","text":"<p>Class for generating kdes from (rt, choice) data. Works for any number of choices.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE--attributes","title":"Attributes","text":"<pre><code>!!! simulator_data \"dict, default&lt;None\"\n    Dictionary of the type {'rts':[], 'choices':[], 'metadata':{}}.\n    Follows the format of simulator returns in this package.\n!!! bandwidth_type \"string\"\n    type of bandwidth to use, default is 'silverman'\n!!! auto_bandwidth \"boolean\"\n    whether to compute bandwidths automatically, default is True\n</code></pre>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE--methods","title":"Methods","text":"<pre><code>compute_bandwidths(type='silverman')\n    Computes bandwidths for each choice from rt data.\ngenerate_base_kdes(auto_bandwidth=True, bandwidth_type='silverman')\n    Generates kdes from rt data.\nkde_eval(data=([], []), log_eval=True)\n    Evaluates kde log likelihood at chosen points.\nkde_sample(n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)\n    Samples from a given kde.\nattach_data_from_simulator(simulator_data={'rts':[0, 2, 4], 'choices':[-1, 1, -1], 'metadata':{}}))\n    Helper function to transform ddm simulator output\n    to dataset suitable for the kde function class.\n</code></pre> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.attach_data_from_simulator","title":"<code>attach_data_from_simulator(self, simulator_data=([0, 2, 4], [-1, 1, -1]), filter_rts=-999)</code>","text":"<p>Helper function to transform ddm simulator output to dataset suitable for the kde function class.</p> <p>tuple</p> <p>Tuple of (rts, choices, simulator_info) as returned by simulator function.</p> <p>float</p> <p>Value to filter rts by, default is -999. -999 is the number returned by the simulators if we breach max_t or deadline.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.compute_bandwidths","title":"<code>compute_bandwidths(self, type='silverman')</code>","text":"<p>Computes bandwidths for each choice from rt data.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of bandwidths for each choice.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.generate_base_kdes","title":"<code>generate_base_kdes(self, auto_bandwidth=True, bandwidth_type='silverman')</code>","text":"<p>Generates kdes from rt data. We apply gaussian kernels to the log of the rts.</p> <p>boolean</p> <p>Whether to compute bandwidths automatically, default is True.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of kdes for each choice. (These get attached to the base_kdes attribute of the class, not returned)</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.kde_eval","title":"<code>kde_eval(self, data={}, log_eval=True, lb=-66.774, eps=0.0001, filter_rts=-999)</code>","text":"<p>Evaluates kde log likelihood at chosen points.</p> <p>dict</p> <p>Dictionary with keys 'rts', and/or 'log_rts' and 'choices' to evaluate the kde at. If 'rts' is provided, 'log_rts' is ignored.</p> <p>boolean</p> <p>Whether to return log likelihood or likelihood, default is True.</p> <p>float</p> <p>Lower bound for log likelihoods, default is -66.774. (This is the log of 1e-29)</p> <p>float</p> <p>Epsilon value to use for lower bounds on rts.</p> <p>float</p> <p>Value to filter rts by, default is -999. -999 is the number returned by the simulators if we breach max_t or deadline.</p> <p>array</p> <p>Array of log likelihoods for each (rt, choice) pair.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.kde_sample","title":"<code>kde_sample(self, n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)</code>","text":"<p>Samples from a given kde.</p> <p>int</p> <p>Number of samples to draw.</p> <p>boolean</p> <p>Whether to use empirical choice proportions, default is True. (Note 'empirical' here, refers to the originally attached datasets that served as the basis to generate the choice-wise kdes)</p> <p>array</p> <p>Array of choice proportions to use, default is 0. (Note 'alternate' here refers to 'alternative' to the 'empirical' choice proportions)</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.bandwidth_silverman","title":"<code>bandwidth_silverman(sample=[0, 0, 0], std_cutoff=0.001, std_proc='restrict', std_n_1=10)</code>","text":"<p>Computes silverman bandwidth for an array of samples (rts in our context, but general).</p> <p>array</p> <p>Array of samples to compute bandwidth for.</p> <p>float</p> <p>Cutoff for std, default is 1e-3. (If sample-std is smaller than this, we either kill it or restrict it to this value)</p> <p>string</p> <p>How to deal with small stds, default is 'restrict'. (Options: 'kill', 'restrict')</p> <p>float</p> <p>Value to use if n = 1, default is 10. (Not clear if the default is sensible here)</p> <p>float</p> <p>Silverman bandwidth for the given sample. This is applied as the bandwidth parameter when generating gaussian-based kdes in the LogKDE class.</p>"},{"location":"api/support_utils/#ssms.support_utils.utils","title":"<code>utils</code>","text":""},{"location":"api/support_utils/#ssms.support_utils.utils.build_dependency_graph","title":"<code>build_dependency_graph(param_dict)</code>","text":"<p>Build a dependency graph based on parameter bounds.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>Dict[str, Tuple[Any, Any]]</code> <p>A dictionary mapping parameter names to their bounds.</p> required <p>Returns:</p> Type Description <code>Dict[str, Set[str]]</code> <p>A dictionary representing the dependency graph where keys are parameter names,                      and values are sets of parameter names they depend on.</p>"},{"location":"api/support_utils/#ssms.support_utils.utils.parse_bounds","title":"<code>parse_bounds(bounds)</code>","text":"<p>Parse the bounds of a parameter and extract any dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Tuple[Any, Any]</code> <p>A tuple containing the lower and upper bounds,                       which can be numeric or strings indicating dependencies.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of parameter names that the bounds depend on.</p>"},{"location":"api/support_utils/#ssms.support_utils.utils.sample_parameters_from_constraints","title":"<code>sample_parameters_from_constraints(param_dict, sample_size)</code>","text":"<p>Sample parameters uniformly within specified bounds, respecting any dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>Dict[str, Tuple[Any, Any]]</code> <p>Dictionary mapping parameter names to their bounds.</p> required <code>sample_size</code> <code>int</code> <p>Number of samples to generate.</p> required <p>Returns:</p> Type Description <code>Dict[str, np.ndarray]</code> <p>A dictionary mapping parameter names to arrays of sampled values.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If dependencies cannot be resolved due to missing parameters or circular dependencies.</p>"},{"location":"api/support_utils/#ssms.support_utils.utils.topological_sort","title":"<code>topological_sort(graph)</code>","text":"<p>Perform a topological sort on the dependency graph to determine the sampling order.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Dict[str, Set[str]]</code> <p>The dependency graph.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of parameter names in the order they should be sampled.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If a circular dependency is detected.</p>"},{"location":"api/support_utils/#ssms.support_utils.utils.topological_sort_util","title":"<code>topological_sort_util(node, visited, stack, graph, temp_marks)</code>","text":"<p>Helper function for performing a depth-first search in the topological sort.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>The current node being visited.</p> required <code>visited</code> <code>Set[str]</code> <p>Set of nodes that have been permanently marked (fully processed).</p> required <code>stack</code> <code>List[str]</code> <p>List representing the ordering of nodes.</p> required <code>graph</code> <code>Dict[str, Set[str]]</code> <p>The dependency graph.</p> required <code>temp_marks</code> <code>Set[str]</code> <p>Set of nodes that have been temporarily marked (currently being processed).</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If a circular dependency is detected.</p>"},{"location":"basic_tutorial/basic_tutorial/","title":"Installation","text":"<p>The <code>ssms</code> package serves two purposes.</p> <ol> <li><p>Easy access to fast simulators of sequential sampling models</p> </li> <li><p>Support infrastructure to construct training data for various approaches to likelihood / posterior amortization</p> </li> </ol> <p>We provide two minimal examples here to illustrate how to use each of the two capabilities.</p> In\u00a0[10]: Copied! <pre># Import necessary packages\nimport numpy as np\nimport pandas as pd\nimport ssms\n</pre> # Import necessary packages import numpy as np import pandas as pd import ssms In\u00a0[11]: Copied! <pre># Check included models\nlist(ssms.config.model_config.keys())[:10]\n</pre> # Check included models list(ssms.config.model_config.keys())[:10] Out[11]: <pre>['ddm',\n 'ddm_legacy',\n 'angle',\n 'weibull',\n 'levy',\n 'levy_angle',\n 'full_ddm',\n 'full_ddm_rv',\n 'ddm_st',\n 'ddm_truncnormt']</pre> In\u00a0[1]: Copied! <pre># Take an example config for a given model\nssms.config.model_config[\"ddm\"]\n</pre> # Take an example config for a given model ssms.config.model_config[\"ddm\"] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[1], line 2\n      1 # Take an example config for a given model\n----&gt; 2 ssms.config.model_config[\"ddm\"]\n\nNameError: name 'ssms' is not defined</pre> <p>Note: The usual structure of these models includes,</p> <ul> <li>Parameter names (<code>'params'</code>)</li> <li>Bounds on the parameters (<code>'param_bounds'</code>)</li> <li>A function that defines a boundary for the respective model (<code>'boundary'</code>)</li> <li>The number of parameters (<code>'n_params'</code>)</li> <li>Defaults for the parameters (<code>'default_params'</code>)</li> <li>The number of choices the process can produce (<code>'nchoices'</code>)</li> </ul> <p>The <code>'hddm_include'</code> key concerns information useful for integration with the hddm python package, which facilitates hierarchical bayesian inference for sequential sampling models. It is not important for the present tutorial.</p> In\u00a0[13]: Copied! <pre>from ssms.basic_simulators.simulator import simulator\n\nsim_out = simulator(\n    model=\"ddm\", theta={\"v\": 0, \"a\": 1, \"z\": 0.5, \"t\": 0.5}, n_samples=1000,\n)\n</pre> from ssms.basic_simulators.simulator import simulator  sim_out = simulator(     model=\"ddm\", theta={\"v\": 0, \"a\": 1, \"z\": 0.5, \"t\": 0.5}, n_samples=1000, ) <p>The output of the simulator is a <code>dictionary</code> with three elements.</p> <ol> <li><code>rts</code> (array)</li> <li><code>choices</code> (array)</li> <li><code>metadata</code> (dictionary)</li> </ol> <p>The <code>metadata</code> includes the named parameters, simulator settings, and more.</p> In\u00a0[14]: Copied! <pre>ssms.config.data_generator_config[\"lan\"]\n</pre> ssms.config.data_generator_config[\"lan\"] Out[14]: <pre>{'output_folder': 'data/lan_mlp/',\n 'model': 'ddm',\n 'nbins': 0,\n 'n_samples': 100000,\n 'n_parameter_sets': 10000,\n 'n_parameter_sets_rejected': 100,\n 'n_training_samples_by_parameter_set': 1000,\n 'max_t': 20.0,\n 'delta_t': 0.001,\n 'pickleprotocol': 4,\n 'n_cpus': 'all',\n 'kde_data_mixture_probabilities': [0.8, 0.1, 0.1],\n 'simulation_filters': {'mode': 20,\n  'choice_cnt': 0,\n  'mean_rt': 17,\n  'std': 0,\n  'mode_cnt_rel': 0.95},\n 'negative_rt_cutoff': -66.77497,\n 'n_subruns': 10,\n 'bin_pointwise': False,\n 'separate_response_channels': False,\n 'smooth_unif': True}</pre> <p>You usually have to make just few changes to this basic configuration dictionary. An example below.</p> In\u00a0[15]: Copied! <pre>from copy import deepcopy\n\n# Initialize the generator config (for MLP LANs)\ngenerator_config = deepcopy(ssms.config.data_generator_config[\"lan\"])\n# Specify generative model (one from the list of included models mentioned above)\ngenerator_config[\"dgp_list\"] = \"angle\"\n# Specify number of parameter sets to simulate\ngenerator_config[\"n_parameter_sets\"] = 100\n# Specify how many samples a simulation run should entail\ngenerator_config[\"n_samples\"] = 1000\n</pre> from copy import deepcopy  # Initialize the generator config (for MLP LANs) generator_config = deepcopy(ssms.config.data_generator_config[\"lan\"]) # Specify generative model (one from the list of included models mentioned above) generator_config[\"dgp_list\"] = \"angle\" # Specify number of parameter sets to simulate generator_config[\"n_parameter_sets\"] = 100 # Specify how many samples a simulation run should entail generator_config[\"n_samples\"] = 1000 <p>Now let's define our corresponding <code>model_config</code>.</p> In\u00a0[16]: Copied! <pre>model_config = ssms.config.model_config[\"angle\"]\nprint(model_config)\n</pre> model_config = ssms.config.model_config[\"angle\"] print(model_config) <pre>{'name': 'angle', 'params': ['v', 'a', 'z', 't', 'theta'], 'param_bounds': [[-3.0, 0.3, 0.1, 0.001, -0.1], [3.0, 3.0, 0.9, 2.0, 1.3]], 'boundary_name': 'angle', 'boundary': &lt;function angle at 0x1260a27a0&gt;, 'n_params': 5, 'default_params': [0.0, 1.0, 0.5, 0.001, 0.0], 'nchoices': 2, 'n_particles': 1, 'simulator': &lt;cyfunction ddm_flexbound at 0x156032f60&gt;}\n</pre> <p>We are now ready to initialize a <code>data_generator</code>, after which we can generate training data using the <code>generate_data_training_uniform</code> function, which will use the hypercube defined by our parameter bounds from the <code>model_config</code> to uniformly generate parameter sets and corresponding simulated datasets.</p> In\u00a0[17]: Copied! <pre>my_dataset_generator = ssms.dataset_generators.lan_mlp.data_generator(\n    generator_config=generator_config, model_config=model_config\n)\n</pre> my_dataset_generator = ssms.dataset_generators.lan_mlp.data_generator(     generator_config=generator_config, model_config=model_config ) <pre>n_cpus used:  12\nchecking:  data/lan_mlp/\n</pre> In\u00a0[18]: Copied! <pre>training_data = my_dataset_generator.generate_data_training_uniform(save=False)\n</pre> training_data = my_dataset_generator.generate_data_training_uniform(save=False) <pre>simulation round: 1  of 10\nsimulation round: 2  of 10\nsimulation round: 3  of 10\nsimulation round: 4  of 10\nsimulation round: 5  of 10\nsimulation round: 6  of 10\nsimulation round: 7  of 10\nsimulation round: 8  of 10\nsimulation round: 9  of 10\nsimulation round: 10  of 10\n</pre> <p><code>training_data</code> is a dictionary containing four keys:</p> <ol> <li><code>data</code> the features for LANs, containing vectors of model parameters, as well as rts and choices.</li> <li><code>labels</code> which contain approximate likelihood values</li> <li><code>generator_config</code>, as defined above</li> <li><code>model_config</code>, as defined above</li> </ol> <p>You can now use this training data for your purposes. If you want to train LANs yourself, you might find the LANfactory package helpful.</p> <p>You may also simply find the basic simulators provided with the ssms package useful, without any desire to use the outputs into training data for amortization purposes.</p>"},{"location":"basic_tutorial/basic_tutorial/#quick-start","title":"Quick Start\u00b6","text":""},{"location":"basic_tutorial/basic_tutorial/#install","title":"Install\u00b6","text":"<p>Let's start with installing the <code>ssms</code> package.</p> <p>You can do so by typing,</p> <p><code>pip install ssm-simulators</code></p> <p>in your terminal.</p> <p>Below you find a basic tutorial on how to use the package.</p>"},{"location":"basic_tutorial/basic_tutorial/#tutorial","title":"Tutorial\u00b6","text":""},{"location":"basic_tutorial/basic_tutorial/#using-the-simulators","title":"Using the Simulators\u00b6","text":"<p>Let's start with using the basic simulators. You access the main simulators through the  <code>ssms.basic_simulators.simulator.simulator()</code> function.</p> <p>To get an idea about the models included in <code>ssms</code>, use the <code>config</code> module. The central dictionary with metadata about included models sits in <code>ssms.config.model_config</code>.</p>"},{"location":"basic_tutorial/basic_tutorial/#using-the-training-data-generators","title":"Using the Training Data Generators\u00b6","text":"<p>The training data generators sit on top of the simulator function to turn raw simulations into usable training data for training machine learning algorithms aimed at posterior or likelihood armortization.</p> <p>We will use the <code>data_generator</code> class from <code>ssms.dataset_generators</code>. Initializing the <code>data_generator</code> boils down to supplying two configuration dictionaries.</p> <ol> <li>The <code>generator_config</code>, concerns choices as to what kind of training data one wants to generate.</li> <li>The <code>model_config</code> concerns choices with respect to the underlying generative sequential sampling model.</li> </ol> <p>We will consider a basic example here, concerning data generation to prepare for training LANs.</p> <p>Let's start by peeking at an example <code>generator_config</code>.</p>"},{"location":"basic_tutorial/basic_tutorial/#end","title":"END\u00b6","text":""}]}