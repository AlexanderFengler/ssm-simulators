{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ssm_simulators","text":"<p>Python Package which collects simulators for Sequential Sampling Models.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The <code>ssms</code> package serves two purposes. </p> <ol> <li> <p>Easy access to fast simulators of sequential sampling models</p> </li> <li> <p>Support infrastructure to construct training data for various approaches to likelihood / posterior amortization</p> </li> </ol> <p>We provide two minimal examples here to illustrate how to use each of the two capabilities.</p>"},{"location":"#install","title":"Install","text":"<p>Let's start with installing the <code>ssms</code> package.</p> <p>You can do so by typing,</p> <p><code>pip install git+https://github.com/AlexanderFengler/ssm_simulators</code></p> <p>in your terminal.</p> <p>Below you find a basic tutorial on how to use the package.</p>"},{"location":"#tutorial","title":"Tutorial","text":"<pre><code># Import necessary packages\nimport numpy as np\nimport pandas as pd\nimport ssms\n</code></pre>"},{"location":"#using-the-simulators","title":"Using the Simulators","text":"<p>Let's start with using the basic simulators.  You access the main simulators through the  <code>ssms.basic_simulators.simulator</code> function.</p> <p>To get an idea about the models included in <code>ssms</code>, use the <code>config</code> module. The central dictionary with metadata about included models sits in <code>ssms.config.model_config</code>. </p> <pre><code># Check included models\nlist(ssms.config.model_config.keys())[:10]\n</code></pre> <pre><code>['ddm',\n 'ddm_legacy',\n 'angle',\n 'weibull',\n 'levy',\n 'levy_angle',\n 'full_ddm',\n 'ornstein',\n 'ornstein_angle',\n 'ddm_sdv']\n</code></pre> <pre><code># Take an example config for a given model\nssms.config.model_config['ddm']\n</code></pre> <pre><code>{'name': 'ddm',\n 'params': ['v', 'a', 'z', 't'],\n 'param_bounds': [[-3.0, 0.3, 0.1, 0.0], [3.0, 2.5, 0.9, 2.0]],\n 'boundary': &lt;function ssms.basic_simulators.boundary_functions.constant(t=0)&gt;,\n 'n_params': 4,\n 'default_params': [0.0, 1.0, 0.5, 0.001],\n 'hddm_include': ['z'],\n 'nchoices': 2}\n</code></pre> <p>Note: The usual structure of these models includes,</p> <ul> <li>Parameter names (<code>'params'</code>)</li> <li>Bounds on the parameters (<code>'param_bounds'</code>)</li> <li>A function that defines a boundary for the respective model (<code>'boundary'</code>)</li> <li>The number of parameters (<code>'n_params'</code>)</li> <li>Defaults for the parameters (<code>'default_params'</code>)</li> <li>The number of choices the process can produce (<code>'nchoices'</code>)</li> </ul> <p>The <code>'hddm_include'</code> key concerns information useful for integration with the hddm python package, which facilitates hierarchical bayesian inference for sequential sampling models. It is not important for the present tutorial.</p> <pre><code>from ssms.basic_simulators import simulator\nsim_out = simulator(model = 'ddm', \ntheta = [0, 1, 0.5, 0.5],\nn_samples = 1000)\n</code></pre> <p>The output of the simulator is a <code>dictionary</code> with three elements.</p> <ol> <li><code>rts</code> (array)</li> <li><code>choices</code> (array)</li> <li><code>metadata</code> (dictionary)</li> </ol> <p>The <code>metadata</code> includes the named parameters, simulator settings, and more.</p>"},{"location":"#using-the-training-data-generators","title":"Using the Training Data Generators","text":"<p>The training data generators sit on top of the simulator function to turn raw simulations into usable training data for training machine learning algorithms aimed at posterior or likelihood armortization.</p> <p>We will use the <code>data_generator</code> class from <code>ssms.dataset_generators</code>. Initializing the <code>data_generator</code> boils down to supplying two configuration dictionaries.</p> <ol> <li>The <code>generator_config</code>, concerns choices as to what kind of training data one wants to generate.</li> <li>The <code>model_config</code> concerns choices with respect to the underlying generative sequential sampling model. </li> </ol> <p>We will consider a basic example here, concerning data generation to prepare for training LANs.</p> <p>Let's start by peeking at an example <code>generator_config</code>.</p> <pre><code>ssms.config.data_generator_config['lan']['mlp']\n</code></pre> <pre><code>{'output_folder': 'data/lan_mlp/',\n 'dgp_list': 'ddm',\n 'nbins': 0,\n 'n_samples': 100000,\n 'n_parameter_sets': 10000,\n 'n_parameter_sets_rejected': 100,\n 'n_training_samples_by_parameter_set': 1000,\n 'max_t': 20.0,\n 'delta_t': 0.001,\n 'pickleprotocol': 4,\n 'n_cpus': 'all',\n 'kde_data_mixture_probabilities': [0.8, 0.1, 0.1],\n 'simulation_filters': {'mode': 20,\n  'choice_cnt': 0,\n  'mean_rt': 17,\n  'std': 0,\n  'mode_cnt_rel': 0.9},\n 'negative_rt_cutoff': -66.77497,\n 'n_subruns': 10,\n 'bin_pointwise': False,\n 'separate_response_channels': False}\n</code></pre> <p>You usually have to make just few changes to this basic configuration dictionary. An example below.</p> <pre><code>from copy import deepcopy\n# Initialize the generator config (for MLP LANs)\ngenerator_config = deepcopy(ssms.config.data_generator_config['lan']['mlp'])\n# Specify generative model (one from the list of included models mentioned above)\ngenerator_config['dgp_list'] = 'angle' \n# Specify number of parameter sets to simulate\ngenerator_config['n_parameter_sets'] = 100 \n# Specify how many samples a simulation run should entail\ngenerator_config['n_samples'] = 1000\n</code></pre> <p>Now let's define our corresponding <code>model_config</code>.</p> <pre><code>model_config = ssms.config.model_config['angle']\nprint(model_config)\n</code></pre> <pre><code>{'name': 'angle', 'params': ['v', 'a', 'z', 't', 'theta'], 'param_bounds': [[-3.0, 0.3, 0.1, 0.001, -0.1], [3.0, 3.0, 0.9, 2.0, 1.3]], 'boundary': &lt;function angle at 0x11b2a7c10&gt;, 'n_params': 5, 'default_params': [0.0, 1.0, 0.5, 0.001, 0.0], 'hddm_include': ['z', 'theta'], 'nchoices': 2}\n</code></pre> <p>We are now ready to initialize a <code>data_generator</code>, after which we can generate training data using the <code>generate_data_training_uniform</code> function, which will use the hypercube defined by our parameter bounds from the <code>model_config</code> to uniformly generate parameter sets and corresponding simulated datasets.</p> <pre><code>my_dataset_generator = ssms.dataset_generators.data_generator(generator_config = generator_config,\nmodel_config = model_config)\n</code></pre> <pre><code>n_cpus used:  6\nchecking:  data/lan_mlp/\n</code></pre> <pre><code>training_data = my_dataset_generator.generate_data_training_uniform(save = False)\n</code></pre> <pre><code>simulation round: 1  of 10\nsimulation round: 2  of 10\nsimulation round: 3  of 10\nsimulation round: 4  of 10\nsimulation round: 5  of 10\nsimulation round: 6  of 10\nsimulation round: 7  of 10\nsimulation round: 8  of 10\nsimulation round: 9  of 10\nsimulation round: 10  of 10\n</code></pre> <p><code>training_data</code> is a dictionary containing four keys:</p> <ol> <li><code>data</code> the features for LANs, containing vectors of model parameters, as well as rts and choices.</li> <li><code>labels</code> which contain approximate likelihood values</li> <li><code>generator_config</code>, as defined above</li> <li><code>model_config</code>, as defined above</li> </ol> <p>You can now use this training data for your purposes. If you want to train LANs yourself, you might find the LANfactory package helpful.</p> <p>You may also simply find the basic simulators provided with the ssms package useful, without any desire to use the outputs into training data for amortization purposes.</p>"},{"location":"#end","title":"END","text":""},{"location":"api/basic_simulators/","title":"basic simulators","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions","title":"ssms.basic_simulators.boundary_functions","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle","title":"angle","text":"<pre><code>angle(t=1, theta=1)\n</code></pre> <p>angle boundary function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 1.\ntheta (int, optional): _description_. Defaults to 1.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound","title":"conflict_gamma_bound","text":"<pre><code>conflict_gamma_bound(t=np.arange(0, 20, 0.1), a=0.5, theta=0.5, scale=1, alpha_gamma=1.01, scale_gamma=0.3)\n</code></pre> <p>conflict bound that allows initial divergence then collapse</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound--arguments","title":"Arguments","text":"<pre><code>t: np.array or float &lt;default = 1&gt;\n    Time/s (with arbitrary measure, but in HDDM it is used as seconds),\n    at which to evaluate the bound.\ntheta: float &lt;default = 0.5&gt;\n    Collapse angle\nscale: float &lt;default = 1.0&gt;\n    Scaling the gamma distribution of the boundary \n    (since bound does not have to integrate to one)\na: float &lt;default = 0.5&gt;\n    Initial boundary separation\nalpha_gamma: float &lt;default = 1.01&gt;\n    alpha parameter for a gamma in scale shape parameterization\nscale_gamma: float &lt;default = 0.3&gt;\n    scale parameter for a gamma in scale shape paraemterization\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant","title":"constant","text":"<pre><code>constant(t=0)\n</code></pre> <p>constant boundary function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 0.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd","title":"generalized_logistic_bnd","text":"<pre><code>generalized_logistic_bnd(t=1, B=2.0, M=3.0, v=0.5)\n</code></pre> <p>generalized logistic bound</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nB (float, optional): Defaults to 2.0.\nM (float, optional): Defaults to 3.0.\nv (float, optional): Defaults to 0.5.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf","title":"weibull_cdf","text":"<pre><code>weibull_cdf(t=1, alpha=1, beta=1)\n</code></pre> <p>boundary based on weibull survival function.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nalpha (int, optional): Defaults to 1.\nbeta (int, optional): Defaults to 1.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions","title":"ssms.basic_simulators.drift_functions","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant","title":"constant","text":"<pre><code>constant(t=np.arange(0, 20, 0.1))\n</code></pre> <p>constant drift function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (_type_, optional): _description_. Defaults to np.arange(0, 20, 0.1).\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of drift values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift","title":"ds_conflict_drift","text":"<pre><code>ds_conflict_drift(t=np.arange(0, 10, 0.001), init_p_t=0, init_p_d=0, slope_t=1, slope_d=1, fixed_p_t=1, coherence_t=1.5, coherence_d=1.5)\n</code></pre> <p>This drift is inspired by a conflict task which     involves a target and a distractor stimuli both presented    simultaneously.     Two drift timecourses are linearly combined weighted     by the coherence in the respective target and distractor stimuli.     Each timecourse follows a dynamical system as described     in the ds_support_analytic() function.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift--arguments","title":"Arguments","text":"<pre><code>t: np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\n    Timepoints at which to evaluate the drift. \n    Usually np.arange() of some sort.\ninit_p_t: float &lt;default=0&gt;\n    Initial condition of target drift timecourse\ninit_p_d: float &lt;default=0&gt;\n    Initial condition of distractor drift timecourse\nslope_t: float &lt;default=1&gt;\n    Slope parameter for target drift timecourse\nslope_d: float &lt;default=1&gt;\n    Slope parameter for distractor drift timecourse\nfixed_p_t: float &lt;default=1&gt;\n    Fixed point for target drift timecourse\ncoherence_t: float &lt;default=1.0&gt;\n    Coefficient for the target drift timecourse\ncoherence_d: float &lt;default=-1.0&gt;\n    Coefficient for the distractor drift timecourse\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift--return","title":"Return","text":"<p>np.ndarray      The full drift timecourse evaluated at the supplied timepoints t.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic","title":"ds_support_analytic","text":"<pre><code>ds_support_analytic(t=np.arange(0, 10, 0.001), init_p=0, fix_point=1, slope=2)\n</code></pre> <p>Solution to differential equation of the form:     x' = slope*(fix_point - x),     with initial condition init_p.     The solution takes the form:     (init_p - fix_point) * exp(-slope * t) + fix_point</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic--arguments","title":"Arguments","text":"<pre><code>t: np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\n    Timepoints at which to evaluate the drift. Usually np.arange() of some sort.\ninit_p: float &lt;default=0&gt;\n    Initial condition of dynamical system\nfix_point: float &lt;default=1&gt;\n    Fixed point of dynamical system\nslope: float &lt;default=0.01&gt;\n    Coefficient in exponent of the solution.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic--return","title":"Return","text":"<p>np.ndarray      The gamma drift evaluated at the supplied timepoints t.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift","title":"gamma_drift","text":"<pre><code>gamma_drift(t=np.arange(0, 20, 0.1), shape=2, scale=0.01, c=1.5)\n</code></pre> <p>Drift function that follows a scaled gamma distribution</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift--arguments","title":"Arguments","text":"<pre><code>t: np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\n    Timepoints at which to evaluate the drift. \n    Usually np.arange() of some sort.\nshape: float &lt;default=2&gt;\n    Shape parameter of the gamma distribution\nscale: float &lt;default=0.01&gt;\n    Scale parameter of the gamma distribution\nc: float &lt;default=1.5&gt;\n    Scalar parameter that scales the peak of \n    the gamma distribution.\n    (Note this function follows a gamma distribution \n    but does not integrate to 1)\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift--return","title":"Return","text":"<pre><code>np.ndarray\n    The gamma drift evaluated at the supplied timepoints t.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator","title":"ssms.basic_simulators.simulator","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_arbitrary_fptd","title":"bin_arbitrary_fptd","text":"<pre><code>bin_arbitrary_fptd(out=None, bin_dt=0.04, nbins=256, nchoices=2, choice_codes=[-1.0, 1.0], max_t=10.0)\n</code></pre> <p>Takes in simulator output and returns a histogram of bin counts Arguments</p> <pre><code>out: tuple\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired bin size \n    which in turn automatically determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into. \n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nnchoices: int &lt;default=2&gt;\n    Number of choices allowed by the simulator.\nchoice_codes = list &lt;default=[-1.0, 1.0]\n    Choice labels to be used.\nmax_t: float\n    Maximum RT to consider.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    2d array (nbins, nchoices): A histogram of bin counts</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output","title":"bin_simulator_output","text":"<pre><code>bin_simulator_output(out=None, bin_dt=0.04, nbins=0, max_t=-1, freq_cnt=False)\n</code></pre> <p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output--arguments","title":"Arguments","text":"<pre><code>out : tuple\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired \n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into. \n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nmax_t : int &lt;default=-1&gt;\n    Override the 'max_t' metadata as part of the simulator output. \n    Sometimes useful, but usually default will do the job.\nfreq_cnt : bool &lt;default=False&gt;\n    Decide whether to return proportions (default) or counts in bins.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    A histogram of counts or proportions.</code>         \u2013          </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise","title":"bin_simulator_output_pointwise","text":"<pre><code>bin_simulator_output_pointwise(out=[0, 0], bin_dt=0.04, nbins=0)\n</code></pre> <p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--arguments","title":"Arguments","text":"<pre><code>out: tuple\n    Output of the 'simulator' function\nbin_dt: float\n    If nbins is 0, this determines the desired \n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins: int\n    Number of bins to bin reaction time data into. \n    If supplied as 0, bin_dt instead determines the \n    number of bins automatically.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    2d array. The first columns collects bin-identifiers </code>         \u2013          <p>by trial, the second column lists the corresponding choices.</p> </li> </ul>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator","title":"simulator","text":"<pre><code>simulator(theta, model='angle', n_samples=1000, delta_t=0.001, max_t=20, no_noise=False, bin_dim=None, bin_pointwise=False, random_state=None)\n</code></pre> <p>Basic data simulator for the models included in HDDM.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator--arguments","title":"Arguments","text":"<pre><code>theta : list or numpy.array\n    Parameters of the simulator. If 2d array, each row is treated as a 'trial'\n    and the function runs n_sample * n_trials simulations.\nmodel: str &lt;default='angle'&gt;\n    Determines the model that will be simulated.\nn_samples: int &lt;default=1000&gt;\n    Number of simulation runs for each row in the theta argument.\ndelta_t: float\n    Size fo timesteps in simulator (conceptually measured in seconds)\nmax_t: float\n    Maximum reaction the simulator can reach\nno_noise: bool &lt;default=False&gt;\n    Turn noise of (useful for plotting purposes mostly)\nbin_dim: int &lt;default=None&gt;\n    Number of bins to use (in case the simulator output is \n    supposed to come out as a count histogram)\nbin_pointwise: bool &lt;default=False&gt;\n    Wheter or not to bin the output data pointwise. \n    If true the 'RT' part of the data is now specifies the\n    'bin-number' of a given trial instead of the 'RT' directly. \n    You need to specify bin_dim as some number for this to work.\nrandom_state: int &lt;default=None&gt;\n    Integer passed to random_seed function in the simulator. \n    Can be used for reproducibility.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator--return","title":"Return","text":"<p>dictionary where keys     can be (rts, responses, metadata)     or     (rt-response histogram, metadata)     or     (rts binned pointwise, responses, metadata)</p>"},{"location":"api/config/","title":"config","text":""},{"location":"api/config/#ssms.config.config","title":"ssms.config.config","text":""},{"location":"api/dataset_generators/","title":"data generators","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp","title":"ssms.dataset_generators.lan_mlp","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator","title":"data_generator","text":"<pre><code>data_generator(generator_config=None, model_config=None)\n</code></pre> <p>The data_generator() class is used to generate training data   for various likelihood approximators.</p> <p>Attributes:</p> <ul> <li> generator_config             (<code>dict</code>)         \u2013          <pre><code>Configuation dictionary for the data generator. \n(For an example load ssms.config.data_generator_config['lan'])\n</code></pre> <p>model_config: dict     Configuration dictionary for the model to be simulated.      (For an example load ssms.config.model_config['ddm'])</p> </li> </ul> <p>Methods:</p> <ul> <li> generate_data_training_uniform           \u2013            <p>Generates training data for LANs. get_simulations(theta=None, random_seed=None)     Generates simulations for a given parameter set. _filter_simulations(simulations=None)     Filters simulations according to the criteria specified in the generator_config. _make_kde_data(simulations=None, theta=None)     Generates KDE data from simulations. _mlp_get_processed_data_for_theta(random_seed_tuple)     Helper function for generating training data for MLPs. _cpn_get_processed_data_for_theta(random_seed_tuple)     Helper function for generating training data for CPNs. _get_rejected_parameter_setups(random_seed_tuple)     Helper function that collectes parameters sets which were rejected     by the filter used in the _filter_simulations() method. _make_save_file_name(unique_tag=None)     Helper function for generating save file names. _build_simulator()     Builds simulator function for LANs. _get_ncpus()     Helper function for determining the number of cpus to use for parallelization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>    data_generator object</code>         \u2013          </li> </ul>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe","title":"ssms.dataset_generators.snpe","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe","title":"data_generator_snpe","text":"<pre><code>data_generator_snpe(generator_config=None, model_config=None)\n</code></pre> <p>             Bases: <code>data_generator</code></p> <pre><code>\n</code></pre> <p>Class for generating data for SNPE.</p> <p>Attributes:</p> <ul> <li> generator_config             (<code>dict</code>)         \u2013          <p>Configuration for data generation</p> </li> <li> model_config             (<code>dict</code>)         \u2013          <p>Configuration for model</p> </li> </ul> <p>Methods:</p> <ul> <li> generate_data_training_uniform           \u2013            <p>Generates data for training SNPE.</p> </li> <li> _snpe_get_processed_data_for_theta           \u2013            <p>Helper function for generating data for SNPE.</p> </li> <li> _build_simulator           \u2013            <p>Builds simulator function for SNPE.</p> </li> </ul>"},{"location":"api/ssms/","title":"ssms","text":""},{"location":"api/ssms/#ssms.basic_simulators","title":"ssms.basic_simulators","text":""},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions","title":"boundary_functions","text":""},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle","title":"angle","text":"<pre><code>angle(t=1, theta=1)\n</code></pre> <p>angle boundary function</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 1.\ntheta (int, optional): _description_. Defaults to 1.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound","title":"conflict_gamma_bound","text":"<pre><code>conflict_gamma_bound(t=np.arange(0, 20, 0.1), a=0.5, theta=0.5, scale=1, alpha_gamma=1.01, scale_gamma=0.3)\n</code></pre> <p>conflict bound that allows initial divergence then collapse</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound--arguments","title":"Arguments","text":"<pre><code>t: np.array or float &lt;default = 1&gt;\n    Time/s (with arbitrary measure, but in HDDM it is used as seconds),\n    at which to evaluate the bound.\ntheta: float &lt;default = 0.5&gt;\n    Collapse angle\nscale: float &lt;default = 1.0&gt;\n    Scaling the gamma distribution of the boundary \n    (since bound does not have to integrate to one)\na: float &lt;default = 0.5&gt;\n    Initial boundary separation\nalpha_gamma: float &lt;default = 1.01&gt;\n    alpha parameter for a gamma in scale shape parameterization\nscale_gamma: float &lt;default = 0.3&gt;\n    scale parameter for a gamma in scale shape paraemterization\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant","title":"constant","text":"<pre><code>constant(t=0)\n</code></pre> <p>constant boundary function</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 0.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd","title":"generalized_logistic_bnd","text":"<pre><code>generalized_logistic_bnd(t=1, B=2.0, M=3.0, v=0.5)\n</code></pre> <p>generalized logistic bound</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nB (float, optional): Defaults to 2.0.\nM (float, optional): Defaults to 3.0.\nv (float, optional): Defaults to 0.5.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf","title":"weibull_cdf","text":"<pre><code>weibull_cdf(t=1, alpha=1, beta=1)\n</code></pre> <p>boundary based on weibull survival function.</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nalpha (int, optional): Defaults to 1.\nbeta (int, optional): Defaults to 1.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of boundary values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions","title":"drift_functions","text":""},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant","title":"constant","text":"<pre><code>constant(t=np.arange(0, 20, 0.1))\n</code></pre> <p>constant drift function</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (_type_, optional): _description_. Defaults to np.arange(0, 20, 0.1).\n</code></pre> <p>Returns:</p> <ul> <li> <code>    np.array: Array of drift values, same length as t</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift","title":"ds_conflict_drift","text":"<pre><code>ds_conflict_drift(t=np.arange(0, 10, 0.001), init_p_t=0, init_p_d=0, slope_t=1, slope_d=1, fixed_p_t=1, coherence_t=1.5, coherence_d=1.5)\n</code></pre> <p>This drift is inspired by a conflict task which     involves a target and a distractor stimuli both presented    simultaneously.     Two drift timecourses are linearly combined weighted     by the coherence in the respective target and distractor stimuli.     Each timecourse follows a dynamical system as described     in the ds_support_analytic() function.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift--arguments","title":"Arguments","text":"<pre><code>t: np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\n    Timepoints at which to evaluate the drift. \n    Usually np.arange() of some sort.\ninit_p_t: float &lt;default=0&gt;\n    Initial condition of target drift timecourse\ninit_p_d: float &lt;default=0&gt;\n    Initial condition of distractor drift timecourse\nslope_t: float &lt;default=1&gt;\n    Slope parameter for target drift timecourse\nslope_d: float &lt;default=1&gt;\n    Slope parameter for distractor drift timecourse\nfixed_p_t: float &lt;default=1&gt;\n    Fixed point for target drift timecourse\ncoherence_t: float &lt;default=1.0&gt;\n    Coefficient for the target drift timecourse\ncoherence_d: float &lt;default=-1.0&gt;\n    Coefficient for the distractor drift timecourse\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift--return","title":"Return","text":"<p>np.ndarray      The full drift timecourse evaluated at the supplied timepoints t.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic","title":"ds_support_analytic","text":"<pre><code>ds_support_analytic(t=np.arange(0, 10, 0.001), init_p=0, fix_point=1, slope=2)\n</code></pre> <p>Solution to differential equation of the form:     x' = slope*(fix_point - x),     with initial condition init_p.     The solution takes the form:     (init_p - fix_point) * exp(-slope * t) + fix_point</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic--arguments","title":"Arguments","text":"<pre><code>t: np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\n    Timepoints at which to evaluate the drift. Usually np.arange() of some sort.\ninit_p: float &lt;default=0&gt;\n    Initial condition of dynamical system\nfix_point: float &lt;default=1&gt;\n    Fixed point of dynamical system\nslope: float &lt;default=0.01&gt;\n    Coefficient in exponent of the solution.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic--return","title":"Return","text":"<p>np.ndarray      The gamma drift evaluated at the supplied timepoints t.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift","title":"gamma_drift","text":"<pre><code>gamma_drift(t=np.arange(0, 20, 0.1), shape=2, scale=0.01, c=1.5)\n</code></pre> <p>Drift function that follows a scaled gamma distribution</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift--arguments","title":"Arguments","text":"<pre><code>t: np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\n    Timepoints at which to evaluate the drift. \n    Usually np.arange() of some sort.\nshape: float &lt;default=2&gt;\n    Shape parameter of the gamma distribution\nscale: float &lt;default=0.01&gt;\n    Scale parameter of the gamma distribution\nc: float &lt;default=1.5&gt;\n    Scalar parameter that scales the peak of \n    the gamma distribution.\n    (Note this function follows a gamma distribution \n    but does not integrate to 1)\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift--return","title":"Return","text":"<pre><code>np.ndarray\n    The gamma drift evaluated at the supplied timepoints t.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator","title":"simulator","text":""},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_arbitrary_fptd","title":"bin_arbitrary_fptd","text":"<pre><code>bin_arbitrary_fptd(out=None, bin_dt=0.04, nbins=256, nchoices=2, choice_codes=[-1.0, 1.0], max_t=10.0)\n</code></pre> <p>Takes in simulator output and returns a histogram of bin counts Arguments</p> <pre><code>out: tuple\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired bin size \n    which in turn automatically determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into. \n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nnchoices: int &lt;default=2&gt;\n    Number of choices allowed by the simulator.\nchoice_codes = list &lt;default=[-1.0, 1.0]\n    Choice labels to be used.\nmax_t: float\n    Maximum RT to consider.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    2d array (nbins, nchoices): A histogram of bin counts</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output","title":"bin_simulator_output","text":"<pre><code>bin_simulator_output(out=None, bin_dt=0.04, nbins=0, max_t=-1, freq_cnt=False)\n</code></pre> <p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output--arguments","title":"Arguments","text":"<pre><code>out : tuple\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired \n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into. \n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nmax_t : int &lt;default=-1&gt;\n    Override the 'max_t' metadata as part of the simulator output. \n    Sometimes useful, but usually default will do the job.\nfreq_cnt : bool &lt;default=False&gt;\n    Decide whether to return proportions (default) or counts in bins.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    A histogram of counts or proportions.</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise","title":"bin_simulator_output_pointwise","text":"<pre><code>bin_simulator_output_pointwise(out=[0, 0], bin_dt=0.04, nbins=0)\n</code></pre> <p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--arguments","title":"Arguments","text":"<pre><code>out: tuple\n    Output of the 'simulator' function\nbin_dt: float\n    If nbins is 0, this determines the desired \n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins: int\n    Number of bins to bin reaction time data into. \n    If supplied as 0, bin_dt instead determines the \n    number of bins automatically.\n</code></pre> <p>Returns:</p> <ul> <li> <code>    2d array. The first columns collects bin-identifiers </code>         \u2013          <p>by trial, the second column lists the corresponding choices.</p> </li> </ul>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator","title":"simulator","text":"<pre><code>simulator(theta, model='angle', n_samples=1000, delta_t=0.001, max_t=20, no_noise=False, bin_dim=None, bin_pointwise=False, random_state=None)\n</code></pre> <p>Basic data simulator for the models included in HDDM.</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator--arguments","title":"Arguments","text":"<pre><code>theta : list or numpy.array\n    Parameters of the simulator. If 2d array, each row is treated as a 'trial'\n    and the function runs n_sample * n_trials simulations.\nmodel: str &lt;default='angle'&gt;\n    Determines the model that will be simulated.\nn_samples: int &lt;default=1000&gt;\n    Number of simulation runs for each row in the theta argument.\ndelta_t: float\n    Size fo timesteps in simulator (conceptually measured in seconds)\nmax_t: float\n    Maximum reaction the simulator can reach\nno_noise: bool &lt;default=False&gt;\n    Turn noise of (useful for plotting purposes mostly)\nbin_dim: int &lt;default=None&gt;\n    Number of bins to use (in case the simulator output is \n    supposed to come out as a count histogram)\nbin_pointwise: bool &lt;default=False&gt;\n    Wheter or not to bin the output data pointwise. \n    If true the 'RT' part of the data is now specifies the\n    'bin-number' of a given trial instead of the 'RT' directly. \n    You need to specify bin_dim as some number for this to work.\nrandom_state: int &lt;default=None&gt;\n    Integer passed to random_seed function in the simulator. \n    Can be used for reproducibility.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator--return","title":"Return","text":"<p>dictionary where keys     can be (rts, responses, metadata)     or     (rt-response histogram, metadata)     or     (rts binned pointwise, responses, metadata)</p>"},{"location":"api/ssms/#ssms.config","title":"ssms.config","text":""},{"location":"api/ssms/#ssms.config.config","title":"config","text":""},{"location":"api/ssms/#ssms.dataset_generators","title":"ssms.dataset_generators","text":""},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp","title":"lan_mlp","text":""},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator","title":"data_generator","text":"<pre><code>data_generator(generator_config=None, model_config=None)\n</code></pre> <p>The data_generator() class is used to generate training data   for various likelihood approximators.</p> <p>Attributes:</p> <ul> <li> generator_config             (<code>dict</code>)         \u2013          <pre><code>Configuation dictionary for the data generator. \n(For an example load ssms.config.data_generator_config['lan'])\n</code></pre> <p>model_config: dict     Configuration dictionary for the model to be simulated.      (For an example load ssms.config.model_config['ddm'])</p> </li> </ul> <p>Methods:</p> <ul> <li> generate_data_training_uniform           \u2013            <p>Generates training data for LANs. get_simulations(theta=None, random_seed=None)     Generates simulations for a given parameter set. _filter_simulations(simulations=None)     Filters simulations according to the criteria specified in the generator_config. _make_kde_data(simulations=None, theta=None)     Generates KDE data from simulations. _mlp_get_processed_data_for_theta(random_seed_tuple)     Helper function for generating training data for MLPs. _cpn_get_processed_data_for_theta(random_seed_tuple)     Helper function for generating training data for CPNs. _get_rejected_parameter_setups(random_seed_tuple)     Helper function that collectes parameters sets which were rejected     by the filter used in the _filter_simulations() method. _make_save_file_name(unique_tag=None)     Helper function for generating save file names. _build_simulator()     Builds simulator function for LANs. _get_ncpus()     Helper function for determining the number of cpus to use for parallelization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>    data_generator object</code>         \u2013          </li> </ul>"},{"location":"api/ssms/#ssms.dataset_generators.snpe","title":"snpe","text":""},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe","title":"data_generator_snpe","text":"<pre><code>data_generator_snpe(generator_config=None, model_config=None)\n</code></pre> <p>             Bases: <code>data_generator</code></p> <pre><code>\n</code></pre> <p>Class for generating data for SNPE.</p> <p>Attributes:</p> <ul> <li> generator_config             (<code>dict</code>)         \u2013          <p>Configuration for data generation</p> </li> <li> model_config             (<code>dict</code>)         \u2013          <p>Configuration for model</p> </li> </ul> <p>Methods:</p> <ul> <li> generate_data_training_uniform           \u2013            <p>Generates data for training SNPE.</p> </li> <li> _snpe_get_processed_data_for_theta           \u2013            <p>Helper function for generating data for SNPE.</p> </li> <li> _build_simulator           \u2013            <p>Builds simulator function for SNPE.</p> </li> </ul>"},{"location":"api/ssms/#ssms.support_utils","title":"ssms.support_utils","text":""},{"location":"api/ssms/#ssms.support_utils.kde_class","title":"kde_class","text":""},{"location":"api/ssms/#ssms.support_utils.kde_class.logkde","title":"logkde","text":"<pre><code>logkde(simulator_data, bandwidth_type='silverman', auto_bandwidth=True)\n</code></pre> <p>Class for generating kdes from (rt, choice) data. Works for any number of choices.</p> <p>Attributes:</p> <ul> <li> simulator_data             (<code>(rt, choice, simulator_info) tuple as returned by simulator function</code>)         \u2013          <p>bandwidth_type: string, type of bandwidth to use, default is 'silverman' auto_bandwidth: boolean, whether to compute bandwidths automatically, default is True</p> </li> </ul> <p>Methods:</p> <ul> <li> compute_bandwidths           \u2013            <p>Computes bandwidths for each choice from rt data. generate_base_kdes(auto_bandwidth=True, bandwidth_type='silverman')     Generates kdes from rt data. kde_eval(data=([], []), log_eval=True)     Evaluates kde log likelihood at chosen points. kde_sample(n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)     Samples from a given kde. attach_data_from_simulator(simulator_data=([0, 2, 4], [-1, 1, -1]))     Helper function to transform ddm simulator output to dataset suitable for the kde function class.</p> </li> </ul> <p>Returns:     type: description</p>"},{"location":"api/support_utils/","title":"Support utils","text":""},{"location":"api/support_utils/#ssms.support_utils.kde_class","title":"ssms.support_utils.kde_class","text":""},{"location":"api/support_utils/#ssms.support_utils.kde_class.logkde","title":"logkde","text":"<pre><code>logkde(simulator_data, bandwidth_type='silverman', auto_bandwidth=True)\n</code></pre> <p>Class for generating kdes from (rt, choice) data. Works for any number of choices.</p> <p>Attributes:</p> <ul> <li> simulator_data             (<code>(rt, choice, simulator_info) tuple as returned by simulator function</code>)         \u2013          <p>bandwidth_type: string, type of bandwidth to use, default is 'silverman' auto_bandwidth: boolean, whether to compute bandwidths automatically, default is True</p> </li> </ul> <p>Methods:</p> <ul> <li> compute_bandwidths           \u2013            <p>Computes bandwidths for each choice from rt data. generate_base_kdes(auto_bandwidth=True, bandwidth_type='silverman')     Generates kdes from rt data. kde_eval(data=([], []), log_eval=True)     Evaluates kde log likelihood at chosen points. kde_sample(n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)     Samples from a given kde. attach_data_from_simulator(simulator_data=([0, 2, 4], [-1, 1, -1]))     Helper function to transform ddm simulator output to dataset suitable for the kde function class.</p> </li> </ul> <p>Returns:     type: description</p>"},{"location":"basic_tutorial/basic_tutorial/","title":"Installation","text":"<p>The <code>ssms</code> package serves two purposes.</p> <ol> <li><p>Easy access to fast simulators of sequential sampling models</p> </li> <li><p>Support infrastructure to construct training data for various approaches to likelihood / posterior amortization</p> </li> </ol> <p>We provide two minimal examples here to illustrate how to use each of the two capabilities.</p> In\u00a0[2]: Copied! <pre># Import necessary packages\nimport numpy as np\nimport pandas as pd\nimport ssms\n</pre> # Import necessary packages import numpy as np import pandas as pd import ssms In\u00a0[3]: Copied! <pre># Check included models\nlist(ssms.config.model_config.keys())[:10]\n</pre> # Check included models list(ssms.config.model_config.keys())[:10] Out[3]: <pre>['ddm',\n 'ddm_legacy',\n 'ddm_deadline',\n 'angle',\n 'weibull',\n 'levy',\n 'levy_angle',\n 'full_ddm',\n 'gamma_drift',\n 'gamma_drift_angle']</pre> In\u00a0[4]: Copied! <pre># Take an example config for a given model\nssms.config.model_config['ddm']\n</pre> # Take an example config for a given model ssms.config.model_config['ddm'] Out[4]: <pre>{'name': 'ddm',\n 'params': ['v', 'a', 'z', 't'],\n 'param_bounds': [[-3.0, 0.3, 0.1, 0.0], [3.0, 2.5, 0.9, 2.0]],\n 'boundary': &lt;function ssms.basic_simulators.boundary_functions.constant(t=0)&gt;,\n 'n_params': 4,\n 'default_params': [0.0, 1.0, 0.5, 0.001],\n 'hddm_include': ['z'],\n 'nchoices': 2}</pre> <p>Note: The usual structure of these models includes,</p> <ul> <li>Parameter names (<code>'params'</code>)</li> <li>Bounds on the parameters (<code>'param_bounds'</code>)</li> <li>A function that defines a boundary for the respective model (<code>'boundary'</code>)</li> <li>The number of parameters (<code>'n_params'</code>)</li> <li>Defaults for the parameters (<code>'default_params'</code>)</li> <li>The number of choices the process can produce (<code>'nchoices'</code>)</li> </ul> <p>The <code>'hddm_include'</code> key concerns information useful for integration with the hddm python package, which facilitates hierarchical bayesian inference for sequential sampling models. It is not important for the present tutorial.</p> In\u00a0[6]: Copied! <pre>from ssms.basic_simulators.simulator import simulator\nsim_out = simulator(model = 'ddm', \n                    theta = {'v': 0, \n                             'a': 1,\n                             'z': 0.5,\n                             't': 0.5},\n                    n_samples = 1000)\n</pre> from ssms.basic_simulators.simulator import simulator sim_out = simulator(model = 'ddm',                      theta = {'v': 0,                               'a': 1,                              'z': 0.5,                              't': 0.5},                     n_samples = 1000) <p>The output of the simulator is a <code>dictionary</code> with three elements.</p> <ol> <li><code>rts</code> (array)</li> <li><code>choices</code> (array)</li> <li><code>metadata</code> (dictionary)</li> </ol> <p>The <code>metadata</code> includes the named parameters, simulator settings, and more.</p> In\u00a0[8]: Copied! <pre>ssms.config.data_generator_config['lan']\n</pre> ssms.config.data_generator_config['lan'] Out[8]: <pre>{'output_folder': 'data/lan_mlp/',\n 'dgp_list': 'ddm',\n 'nbins': 0,\n 'n_samples': 100000,\n 'n_parameter_sets': 10000,\n 'n_parameter_sets_rejected': 100,\n 'n_training_samples_by_parameter_set': 1000,\n 'max_t': 20.0,\n 'delta_t': 0.001,\n 'pickleprotocol': 4,\n 'n_cpus': 'all',\n 'kde_data_mixture_probabilities': [0.8, 0.1, 0.1],\n 'simulation_filters': {'mode': 20,\n  'choice_cnt': 0,\n  'mean_rt': 17,\n  'std': 0,\n  'mode_cnt_rel': 0.9},\n 'negative_rt_cutoff': -66.77497,\n 'n_subruns': 10,\n 'bin_pointwise': False,\n 'separate_response_channels': False}</pre> <p>You usually have to make just few changes to this basic configuration dictionary. An example below.</p> In\u00a0[9]: Copied! <pre>from copy import deepcopy\n# Initialize the generator config (for MLP LANs)\ngenerator_config = deepcopy(ssms.config.data_generator_config['lan'])\n# Specify generative model (one from the list of included models mentioned above)\ngenerator_config['dgp_list'] = 'angle' \n# Specify number of parameter sets to simulate\ngenerator_config['n_parameter_sets'] = 100 \n# Specify how many samples a simulation run should entail\ngenerator_config['n_samples'] = 1000\n</pre> from copy import deepcopy # Initialize the generator config (for MLP LANs) generator_config = deepcopy(ssms.config.data_generator_config['lan']) # Specify generative model (one from the list of included models mentioned above) generator_config['dgp_list'] = 'angle'  # Specify number of parameter sets to simulate generator_config['n_parameter_sets'] = 100  # Specify how many samples a simulation run should entail generator_config['n_samples'] = 1000 <p>Now let's define our corresponding <code>model_config</code>.</p> In\u00a0[10]: Copied! <pre>model_config = ssms.config.model_config['angle']\nprint(model_config)\n</pre> model_config = ssms.config.model_config['angle'] print(model_config) <pre>{'name': 'angle', 'params': ['v', 'a', 'z', 't', 'theta'], 'param_bounds': [[-3.0, 0.3, 0.1, 0.001, -0.1], [3.0, 3.0, 0.9, 2.0, 1.3]], 'boundary': &lt;function angle at 0x125e060c0&gt;, 'n_params': 5, 'default_params': [0.0, 1.0, 0.5, 0.001, 0.0], 'hddm_include': ['z', 'theta'], 'nchoices': 2}\n</pre> <p>We are now ready to initialize a <code>data_generator</code>, after which we can generate training data using the <code>generate_data_training_uniform</code> function, which will use the hypercube defined by our parameter bounds from the <code>model_config</code> to uniformly generate parameter sets and corresponding simulated datasets.</p> In\u00a0[14]: Copied! <pre>my_dataset_generator = ssms.dataset_generators.lan_mlp.data_generator(generator_config = generator_config,\n                                                                   model_config = model_config)\n</pre> my_dataset_generator = ssms.dataset_generators.lan_mlp.data_generator(generator_config = generator_config,                                                                    model_config = model_config) <pre>n_cpus used:  6\nchecking:  data/lan_mlp/\n</pre> In\u00a0[15]: Copied! <pre>training_data = my_dataset_generator.generate_data_training_uniform(save = False)\n</pre> training_data = my_dataset_generator.generate_data_training_uniform(save = False) <pre>simulation round: 1  of 10\nsimulation round: 2  of 10\nsimulation round: 3  of 10\nsimulation round: 4  of 10\nsimulation round: 5  of 10\nsimulation round: 6  of 10\nsimulation round: 7  of 10\nsimulation round: 8  of 10\nsimulation round: 9  of 10\nsimulation round: 10  of 10\n</pre> <p><code>training_data</code> is a dictionary containing four keys:</p> <ol> <li><code>data</code> the features for LANs, containing vectors of model parameters, as well as rts and choices.</li> <li><code>labels</code> which contain approximate likelihood values</li> <li><code>generator_config</code>, as defined above</li> <li><code>model_config</code>, as defined above</li> </ol> <p>You can now use this training data for your purposes. If you want to train LANs yourself, you might find the LANfactory package helpful.</p> <p>You may also simply find the basic simulators provided with the ssms package useful, without any desire to use the outputs into training data for amortization purposes.</p>"},{"location":"basic_tutorial/basic_tutorial/#quick-start","title":"Quick Start\u00b6","text":""},{"location":"basic_tutorial/basic_tutorial/#install","title":"Install\u00b6","text":"<p>Let's start with installing the <code>ssms</code> package.</p> <p>You can do so by typing,</p> <p><code>pip install git+https://github.com/AlexanderFengler/ssm_simulators</code></p> <p>in your terminal.</p> <p>Below you find a basic tutorial on how to use the package.</p>"},{"location":"basic_tutorial/basic_tutorial/#tutorial","title":"Tutorial\u00b6","text":""},{"location":"basic_tutorial/basic_tutorial/#using-the-simulators","title":"Using the Simulators\u00b6","text":"<p>Let's start with using the basic simulators. You access the main simulators through the  <code>ssms.basic_simulators.simulator</code> function.</p> <p>To get an idea about the models included in <code>ssms</code>, use the <code>config</code> module. The central dictionary with metadata about included models sits in <code>ssms.config.model_config</code>.</p>"},{"location":"basic_tutorial/basic_tutorial/#using-the-training-data-generators","title":"Using the Training Data Generators\u00b6","text":"<p>The training data generators sit on top of the simulator function to turn raw simulations into usable training data for training machine learning algorithms aimed at posterior or likelihood armortization.</p> <p>We will use the <code>data_generator</code> class from <code>ssms.dataset_generators</code>. Initializing the <code>data_generator</code> boils down to supplying two configuration dictionaries.</p> <ol> <li>The <code>generator_config</code>, concerns choices as to what kind of training data one wants to generate.</li> <li>The <code>model_config</code> concerns choices with respect to the underlying generative sequential sampling model.</li> </ol> <p>We will consider a basic example here, concerning data generation to prepare for training LANs.</p> <p>Let's start by peeking at an example <code>generator_config</code>.</p>"},{"location":"basic_tutorial/basic_tutorial/#end","title":"END\u00b6","text":""}]}