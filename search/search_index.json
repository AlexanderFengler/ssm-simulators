{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ssm_simulators","text":"<p>Python Package which collects simulators for Sequential Sampling Models.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The <code>ssms</code> package serves two purposes. </p> <ol> <li> <p>Easy access to fast simulators of sequential sampling models</p> </li> <li> <p>Support infrastructure to construct training data for various approaches to likelihood / posterior amortization</p> </li> </ol> <p>We provide two minimal examples here to illustrate how to use each of the two capabilities.</p>"},{"location":"#install","title":"Install","text":"<p>Let's start with installing the <code>ssms</code> package.</p> <p>You can do so by typing,</p> <p><code>pip install git+https://github.com/AlexanderFengler/ssm_simulators</code></p> <p>in your terminal.</p> <p>Below you find a basic tutorial on how to use the package.</p>"},{"location":"#tutorial","title":"Tutorial","text":"<pre><code># Import necessary packages\nimport numpy as np\nimport pandas as pd\nimport ssms\n</code></pre>"},{"location":"#using-the-simulators","title":"Using the Simulators","text":"<p>Let's start with using the basic simulators.  You access the main simulators through the  <code>ssms.basic_simulators.simulator</code> function.</p> <p>To get an idea about the models included in <code>ssms</code>, use the <code>config</code> module. The central dictionary with metadata about included models sits in <code>ssms.config.model_config</code>. </p> <pre><code># Check included models\nlist(ssms.config.model_config.keys())[:10]\n</code></pre> <pre><code>['ddm',\n 'ddm_legacy',\n 'angle',\n 'weibull',\n 'levy',\n 'levy_angle',\n 'full_ddm',\n 'ornstein',\n 'ornstein_angle',\n 'ddm_sdv']\n</code></pre> <pre><code># Take an example config for a given model\nssms.config.model_config['ddm']\n</code></pre> <pre><code>{'name': 'ddm',\n 'params': ['v', 'a', 'z', 't'],\n 'param_bounds': [[-3.0, 0.3, 0.1, 0.0], [3.0, 2.5, 0.9, 2.0]],\n 'boundary': &lt;function ssms.basic_simulators.boundary_functions.constant(t=0)&gt;,\n 'n_params': 4,\n 'default_params': [0.0, 1.0, 0.5, 0.001],\n 'hddm_include': ['z'],\n 'nchoices': 2}\n</code></pre> <p>Note: The usual structure of these models includes,</p> <ul> <li>Parameter names (<code>'params'</code>)</li> <li>Bounds on the parameters (<code>'param_bounds'</code>)</li> <li>A function that defines a boundary for the respective model (<code>'boundary'</code>)</li> <li>The number of parameters (<code>'n_params'</code>)</li> <li>Defaults for the parameters (<code>'default_params'</code>)</li> <li>The number of choices the process can produce (<code>'nchoices'</code>)</li> </ul> <p>The <code>'hddm_include'</code> key concerns information useful for integration with the hddm python package, which facilitates hierarchical bayesian inference for sequential sampling models. It is not important for the present tutorial.</p> <pre><code>from ssms.basic_simulators import simulator\nsim_out = simulator(model = 'ddm', \n                    theta = [0, 1, 0.5, 0.5],\n                    n_samples = 1000)\n</code></pre> <p>The output of the simulator is a <code>dictionary</code> with three elements.</p> <ol> <li><code>rts</code> (array)</li> <li><code>choices</code> (array)</li> <li><code>metadata</code> (dictionary)</li> </ol> <p>The <code>metadata</code> includes the named parameters, simulator settings, and more.</p>"},{"location":"#using-the-training-data-generators","title":"Using the Training Data Generators","text":"<p>The training data generators sit on top of the simulator function to turn raw simulations into usable training data for training machine learning algorithms aimed at posterior or likelihood armortization.</p> <p>We will use the <code>data_generator</code> class from <code>ssms.dataset_generators</code>. Initializing the <code>data_generator</code> boils down to supplying two configuration dictionaries.</p> <ol> <li>The <code>generator_config</code>, concerns choices as to what kind of training data one wants to generate.</li> <li>The <code>model_config</code> concerns choices with respect to the underlying generative sequential sampling model. </li> </ol> <p>We will consider a basic example here, concerning data generation to prepare for training LANs.</p> <p>Let's start by peeking at an example <code>generator_config</code>.</p> <pre><code>ssms.config.data_generator_config['lan']['mlp']\n</code></pre> <pre><code>{'output_folder': 'data/lan_mlp/',\n 'dgp_list': 'ddm',\n 'nbins': 0,\n 'n_samples': 100000,\n 'n_parameter_sets': 10000,\n 'n_parameter_sets_rejected': 100,\n 'n_training_samples_by_parameter_set': 1000,\n 'max_t': 20.0,\n 'delta_t': 0.001,\n 'pickleprotocol': 4,\n 'n_cpus': 'all',\n 'kde_data_mixture_probabilities': [0.8, 0.1, 0.1],\n 'simulation_filters': {'mode': 20,\n  'choice_cnt': 0,\n  'mean_rt': 17,\n  'std': 0,\n  'mode_cnt_rel': 0.9},\n 'negative_rt_cutoff': -66.77497,\n 'n_subruns': 10,\n 'bin_pointwise': False,\n 'separate_response_channels': False}\n</code></pre> <p>You usually have to make just few changes to this basic configuration dictionary. An example below.</p> <pre><code>from copy import deepcopy\n# Initialize the generator config (for MLP LANs)\ngenerator_config = deepcopy(ssms.config.data_generator_config['lan']['mlp'])\n# Specify generative model (one from the list of included models mentioned above)\ngenerator_config['dgp_list'] = 'angle' \n# Specify number of parameter sets to simulate\ngenerator_config['n_parameter_sets'] = 100 \n# Specify how many samples a simulation run should entail\ngenerator_config['n_samples'] = 1000\n</code></pre> <p>Now let's define our corresponding <code>model_config</code>.</p> <pre><code>model_config = ssms.config.model_config['angle']\nprint(model_config)\n</code></pre> <pre><code>{'name': 'angle', 'params': ['v', 'a', 'z', 't', 'theta'], 'param_bounds': [[-3.0, 0.3, 0.1, 0.001, -0.1], [3.0, 3.0, 0.9, 2.0, 1.3]], 'boundary': &lt;function angle at 0x11b2a7c10&gt;, 'n_params': 5, 'default_params': [0.0, 1.0, 0.5, 0.001, 0.0], 'hddm_include': ['z', 'theta'], 'nchoices': 2}\n</code></pre> <p>We are now ready to initialize a <code>data_generator</code>, after which we can generate training data using the <code>generate_data_training_uniform</code> function, which will use the hypercube defined by our parameter bounds from the <code>model_config</code> to uniformly generate parameter sets and corresponding simulated datasets.</p> <pre><code>my_dataset_generator = ssms.dataset_generators.data_generator(generator_config = generator_config,\n                                                              model_config = model_config)\n</code></pre> <pre><code>n_cpus used:  6\nchecking:  data/lan_mlp/\n</code></pre> <pre><code>training_data = my_dataset_generator.generate_data_training_uniform(save = False)\n</code></pre> <pre><code>simulation round: 1  of 10\nsimulation round: 2  of 10\nsimulation round: 3  of 10\nsimulation round: 4  of 10\nsimulation round: 5  of 10\nsimulation round: 6  of 10\nsimulation round: 7  of 10\nsimulation round: 8  of 10\nsimulation round: 9  of 10\nsimulation round: 10  of 10\n</code></pre> <p><code>training_data</code> is a dictionary containing four keys:</p> <ol> <li><code>data</code> the features for LANs, containing vectors of model parameters, as well as rts and choices.</li> <li><code>labels</code> which contain approximate likelihood values</li> <li><code>generator_config</code>, as defined above</li> <li><code>model_config</code>, as defined above</li> </ol> <p>You can now use this training data for your purposes. If you want to train LANs yourself, you might find the LANfactory package helpful.</p> <p>You may also simply find the basic simulators provided with the ssms package useful, without any desire to use the outputs into training data for amortization purposes.</p>"},{"location":"#end","title":"END","text":""},{"location":"api/basic_simulators/","title":"basic simulators","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions","title":"<code>boundary_functions</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle","title":"<code>angle(t=1, theta=1)</code>","text":"<p>angle boundary function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 1.\ntheta (int, optional): _description_. Defaults to 1.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.angle--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound","title":"<code>conflict_gamma_bound(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), a=0.5, theta=0.5, scale=1, alpha_gamma=1.01, scale_gamma=0.3)</code>","text":"<p>conflict bound that allows initial divergence then collapse</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.array or float &lt;default = 1&gt;\"\n    Time/s (with arbitrary measure, but in HDDM it is used as seconds),\n    at which to evaluate the bound.\n!!! theta \"float &lt;default = 0.5&gt;\"\n    Collapse angle\n!!! scale \"float &lt;default = 1.0&gt;\"\n    Scaling the gamma distribution of the boundary\n    (since bound does not have to integrate to one)\n!!! a \"float &lt;default = 0.5&gt;\"\n    Initial boundary separation\n!!! alpha_gamma \"float &lt;default = 1.01&gt;\"\n    alpha parameter for a gamma in scale shape parameterization\n!!! scale_gamma \"float &lt;default = 0.3&gt;\"\n    scale parameter for a gamma in scale shape paraemterization\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant","title":"<code>constant(t=0)</code>","text":"<p>constant boundary function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 0.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.constant--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd","title":"<code>generalized_logistic_bnd(t=1, B=2.0, M=3.0, v=0.5)</code>","text":"<p>generalized logistic bound</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nB (float, optional): Defaults to 2.0.\nM (float, optional): Defaults to 3.0.\nv (float, optional): Defaults to 0.5.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf","title":"<code>weibull_cdf(t=1, alpha=1, beta=1)</code>","text":"<p>boundary based on weibull survival function.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nalpha (int, optional): Defaults to 1.\nbeta (int, optional): Defaults to 1.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.boundary_functions.weibull_cdf--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions","title":"<code>drift_functions</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant","title":"<code>constant(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]))</code>","text":"<p>constant drift function</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (_type_, optional): _description_. Defaults to np.arange(0, 20, 0.1).\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.constant--returns","title":"Returns","text":"<pre><code>np.array: Array of drift values, same length as t\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift","title":"<code>ds_conflict_drift(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), init_p_t=0, init_p_d=0, slope_t=1, slope_d=1, fixed_p_t=1, coherence_t=1.5, coherence_d=1.5)</code>","text":"<p>This drift is inspired by a conflict task which    involves a target and a distractor stimuli both presented    simultaneously.    Two drift timecourses are linearly combined weighted    by the coherence in the respective target and distractor stimuli.    Each timecourse follows a dynamical system as described    in the ds_support_analytic() function.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! init_p_t \"float &lt;default=0&gt;\"\n    Initial condition of target drift timecourse\n!!! init_p_d \"float &lt;default=0&gt;\"\n    Initial condition of distractor drift timecourse\n!!! slope_t \"float &lt;default=1&gt;\"\n    Slope parameter for target drift timecourse\n!!! slope_d \"float &lt;default=1&gt;\"\n    Slope parameter for distractor drift timecourse\n!!! fixed_p_t \"float &lt;default=1&gt;\"\n    Fixed point for target drift timecourse\n!!! coherence_t \"float &lt;default=1.0&gt;\"\n    Coefficient for the target drift timecourse\n!!! coherence_d \"float &lt;default=-1.0&gt;\"\n    Coefficient for the distractor drift timecourse\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_conflict_drift--return","title":"Return","text":"<p>np.ndarray      The full drift timecourse evaluated at the supplied timepoints t.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic","title":"<code>ds_support_analytic(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), init_p=0, fix_point=1, slope=2)</code>","text":"<p>Solution to differential equation of the form:    x' = slope*(fix_point - x),    with initial condition init_p.    The solution takes the form:    (init_p - fix_point) * exp(-slope * t) + fix_point</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\"\n    Timepoints at which to evaluate the drift. Usually np.arange() of some sort.\n!!! init_p \"float &lt;default=0&gt;\"\n    Initial condition of dynamical system\n!!! fix_point \"float &lt;default=1&gt;\"\n    Fixed point of dynamical system\n!!! slope \"float &lt;default=0.01&gt;\"\n    Coefficient in exponent of the solution.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.ds_support_analytic--return","title":"Return","text":"<p>np.ndarray      The gamma drift evaluated at the supplied timepoints t.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift","title":"<code>gamma_drift(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), shape=2, scale=0.01, c=1.5)</code>","text":"<p>Drift function that follows a scaled gamma distribution</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! shape \"float &lt;default=2&gt;\"\n    Shape parameter of the gamma distribution\n!!! scale \"float &lt;default=0.01&gt;\"\n    Scale parameter of the gamma distribution\n!!! c \"float &lt;default=1.5&gt;\"\n    Scalar parameter that scales the peak of\n    the gamma distribution.\n    (Note this function follows a gamma distribution\n    but does not integrate to 1)\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.drift_functions.gamma_drift--return","title":"Return","text":"<pre><code>np.ndarray\n    The gamma drift evaluated at the supplied timepoints t.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator","title":"<code>simulator</code>","text":""},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_arbitrary_fptd","title":"<code>bin_arbitrary_fptd(out=None, bin_dt=0.04, nbins=256, nchoices=2, choice_codes=[-1.0, 1.0], max_t=10.0)</code>","text":"<p>Takes in simulator output and returns a histogram of bin counts Arguments</p> <pre><code>!!! out \"tuple\"\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired bin size\n    which in turn automatically determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\n!!! nchoices \"int &lt;default=2&gt;\"\n    Number of choices allowed by the simulator.\nchoice_codes = list &lt;default=[-1.0, 1.0]\n    Choice labels to be used.\n!!! max_t \"float\"\n    Maximum RT to consider.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_arbitrary_fptd--returns","title":"Returns","text":"<pre><code>2d array (nbins, nchoices): A histogram of bin counts\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output","title":"<code>bin_simulator_output(out=None, bin_dt=0.04, nbins=0, max_t=-1, freq_cnt=False)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output--arguments","title":"Arguments","text":"<pre><code>out : tuple\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nmax_t : int &lt;default=-1&gt;\n    Override the 'max_t' metadata as part of the simulator output.\n    Sometimes useful, but usually default will do the job.\nfreq_cnt : bool &lt;default=False&gt;\n    Decide whether to return proportions (default) or counts in bins.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output--returns","title":"Returns","text":"<pre><code>A histogram of counts or proportions.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise","title":"<code>bin_simulator_output_pointwise(out=[0, 0], bin_dt=0.04, nbins=0)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--arguments","title":"Arguments","text":"<pre><code>!!! out \"tuple\"\n    Output of the 'simulator' function\n!!! bin_dt \"float\"\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\n!!! nbins \"int\"\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the\n    number of bins automatically.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--returns","title":"Returns","text":"<pre><code>2d array. The first columns collects bin-identifiers\nby trial, the second column lists the corresponding choices.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator","title":"<code>simulator(theta, model='angle', n_samples=1000, delta_t=0.001, max_t=20, no_noise=False, bin_dim=None, bin_pointwise=False, smooth_unif=True, random_state=None)</code>","text":"<p>Basic data simulator for the models included in HDDM.</p>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator--arguments","title":"Arguments","text":"<pre><code>theta : list, numpy.array, dict or pd.DataFrame\n    Parameters of the simulator. If 2d array, each row is treated as a 'trial'\n    and the function runs n_sample * n_trials simulations.\n!!! model \"str &lt;default='angle'&gt;\"\n    Determines the model that will be simulated.\n!!! n_samples \"int &lt;default=1000&gt;\"\n    Number of simulation runs for each row in the theta argument.\n!!! delta_t \"float\"\n    Size fo timesteps in simulator (conceptually measured in seconds)\n!!! max_t \"float\"\n    Maximum reaction the simulator can reach\n!!! no_noise \"bool &lt;default=False&gt;\"\n    Turn noise of (useful for plotting purposes mostly)\n!!! bin_dim \"int &lt;default=None&gt;\"\n    Number of bins to use (in case the simulator output is\n    supposed to come out as a count histogram)\n!!! bin_pointwise \"bool &lt;default=False&gt;\"\n    Wheter or not to bin the output data pointwise.\n    If true the 'RT' part of the data is now specifies the\n    'bin-number' of a given trial instead of the 'RT' directly.\n    You need to specify bin_dim as some number for this to work.\n!!! random_state \"int &lt;default=None&gt;\"\n    Integer passed to random_seed function in the simulator.\n    Can be used for reproducibility.\n</code></pre>"},{"location":"api/basic_simulators/#ssms.basic_simulators.simulator.simulator--return","title":"Return","text":"<p>dictionary where keys     can be (rts, responses, metadata)     or     (rt-response histogram, metadata)     or     (rts binned pointwise, responses, metadata)</p>"},{"location":"api/config/","title":"config","text":""},{"location":"api/dataset_generators/","title":"data generators","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp","title":"<code>lan_mlp</code>","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator","title":"<code> data_generator        </code>","text":"<p>The data_generator() class is used to generate training data   for various likelihood approximators.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator--attributes","title":"Attributes","text":"<pre><code>!!! generator_config \"dict\"\n    Configuation dictionary for the data generator.\n    (For an example load ssms.config.data_generator_config['lan'])\n!!! model_config \"dict\"\n    Configuration dictionary for the model to be simulated.\n    (For an example load ssms.config.model_config['ddm'])\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator--methods","title":"Methods","text":"<pre><code>generate_data_training_uniform(save=False, verbose=True, cpn_only=False)\n    Generates training data for LANs.\nget_simulations(theta=None, random_seed=None)\n    Generates simulations for a given parameter set.\n_filter_simulations(simulations=None)\n    Filters simulations according to the criteria\n    specified in the generator_config.\n_make_kde_data(simulations=None, theta=None)\n    Generates KDE data from simulations.\n_mlp_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for MLPs.\n_cpn_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for CPNs.\n_get_rejected_parameter_setups(random_seed_tuple)\n    Helper function that collectes parameters sets which were rejected\n    by the filter used in the _filter_simulations() method.\n_make_save_file_name(unique_tag=None)\n    Helper function for generating save file names.\n_build_simulator()\n    Builds simulator function for LANs.\n_get_ncpus()\n    Helper function for determining the number of\n    cpus to use for parallelization.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator--returns","title":"Returns","text":"<pre><code>data_generator object\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False, verbose=True, cpn_only=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe","title":"<code>snpe</code>","text":""},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe","title":"<code> data_generator_snpe            (data_generator)         </code>","text":"<p>Class for generating data for SNPE.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe--attributes","title":"Attributes","text":"<p>dict</p> <p>Configuration for data generation</p> <p>dict</p> <p>Configuration for model</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe--methods","title":"Methods","text":"<p>generate_data_training_uniform(save=False)     Generates data for training SNPE. _snpe_get_processed_data_for_theta(random_seed)     Helper function for generating data for SNPE. _build_simulator()     Builds simulator function for SNPE.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/dataset_generators/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/ssms/","title":"ssms","text":""},{"location":"api/ssms/#ssms.basic_simulators","title":"<code>basic_simulators</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions","title":"<code>boundary_functions</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle","title":"<code>angle(t=1, theta=1)</code>","text":"<p>angle boundary function</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 1.\ntheta (int, optional): _description_. Defaults to 1.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.angle--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound","title":"<code>conflict_gamma_bound(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), a=0.5, theta=0.5, scale=1, alpha_gamma=1.01, scale_gamma=0.3)</code>","text":"<p>conflict bound that allows initial divergence then collapse</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.array or float &lt;default = 1&gt;\"\n    Time/s (with arbitrary measure, but in HDDM it is used as seconds),\n    at which to evaluate the bound.\n!!! theta \"float &lt;default = 0.5&gt;\"\n    Collapse angle\n!!! scale \"float &lt;default = 1.0&gt;\"\n    Scaling the gamma distribution of the boundary\n    (since bound does not have to integrate to one)\n!!! a \"float &lt;default = 0.5&gt;\"\n    Initial boundary separation\n!!! alpha_gamma \"float &lt;default = 1.01&gt;\"\n    alpha parameter for a gamma in scale shape parameterization\n!!! scale_gamma \"float &lt;default = 0.3&gt;\"\n    scale parameter for a gamma in scale shape paraemterization\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.conflict_gamma_bound--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant","title":"<code>constant(t=0)</code>","text":"<p>constant boundary function</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (int, optional): _description_. Defaults to 0.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.constant--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd","title":"<code>generalized_logistic_bnd(t=1, B=2.0, M=3.0, v=0.5)</code>","text":"<p>generalized logistic bound</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nB (float, optional): Defaults to 2.0.\nM (float, optional): Defaults to 3.0.\nv (float, optional): Defaults to 0.5.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.generalized_logistic_bnd--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf","title":"<code>weibull_cdf(t=1, alpha=1, beta=1)</code>","text":"<p>boundary based on weibull survival function.</p>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf--arguments","title":"Arguments","text":"<pre><code>t (int, optional): Defaults to 1.\nalpha (int, optional): Defaults to 1.\nbeta (int, optional): Defaults to 1.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.boundary_functions.weibull_cdf--returns","title":"Returns","text":"<pre><code>np.array: Array of boundary values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions","title":"<code>drift_functions</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant","title":"<code>constant(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]))</code>","text":"<p>constant drift function</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant--arguments","title":"Arguments","text":"<pre><code>t (_type_, optional): _description_. Defaults to np.arange(0, 20, 0.1).\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.constant--returns","title":"Returns","text":"<pre><code>np.array: Array of drift values, same length as t\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift","title":"<code>ds_conflict_drift(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), init_p_t=0, init_p_d=0, slope_t=1, slope_d=1, fixed_p_t=1, coherence_t=1.5, coherence_d=1.5)</code>","text":"<p>This drift is inspired by a conflict task which    involves a target and a distractor stimuli both presented    simultaneously.    Two drift timecourses are linearly combined weighted    by the coherence in the respective target and distractor stimuli.    Each timecourse follows a dynamical system as described    in the ds_support_analytic() function.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! init_p_t \"float &lt;default=0&gt;\"\n    Initial condition of target drift timecourse\n!!! init_p_d \"float &lt;default=0&gt;\"\n    Initial condition of distractor drift timecourse\n!!! slope_t \"float &lt;default=1&gt;\"\n    Slope parameter for target drift timecourse\n!!! slope_d \"float &lt;default=1&gt;\"\n    Slope parameter for distractor drift timecourse\n!!! fixed_p_t \"float &lt;default=1&gt;\"\n    Fixed point for target drift timecourse\n!!! coherence_t \"float &lt;default=1.0&gt;\"\n    Coefficient for the target drift timecourse\n!!! coherence_d \"float &lt;default=-1.0&gt;\"\n    Coefficient for the distractor drift timecourse\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_conflict_drift--return","title":"Return","text":"<p>np.ndarray      The full drift timecourse evaluated at the supplied timepoints t.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic","title":"<code>ds_support_analytic(t=array([0.000e+00, 1.000e-03, 2.000e-03, ..., 9.997e+00, 9.998e+00,9.999e+00]), init_p=0, fix_point=1, slope=2)</code>","text":"<p>Solution to differential equation of the form:    x' = slope*(fix_point - x),    with initial condition init_p.    The solution takes the form:    (init_p - fix_point) * exp(-slope * t) + fix_point</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\"\n    Timepoints at which to evaluate the drift. Usually np.arange() of some sort.\n!!! init_p \"float &lt;default=0&gt;\"\n    Initial condition of dynamical system\n!!! fix_point \"float &lt;default=1&gt;\"\n    Fixed point of dynamical system\n!!! slope \"float &lt;default=0.01&gt;\"\n    Coefficient in exponent of the solution.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.ds_support_analytic--return","title":"Return","text":"<p>np.ndarray      The gamma drift evaluated at the supplied timepoints t.</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift","title":"<code>gamma_drift(t=array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ,1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1,2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2,3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4. , 4.1, 4.2, 4.3,4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 5. , 5.1, 5.2, 5.3, 5.4,5.5, 5.6, 5.7, 5.8, 5.9, 6. , 6.1, 6.2, 6.3, 6.4, 6.5,6.6, 6.7, 6.8, 6.9, 7. , 7.1, 7.2, 7.3, 7.4, 7.5, 7.6,7.7, 7.8, 7.9, 8. , 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7,8.8, 8.9, 9. , 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8,9.9, 10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9,11. , 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8, 11.9, 12. ,12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8, 12.9, 13. , 13.1,13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14. , 14.1, 14.2,14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 14.9, 15. , 15.1, 15.2, 15.3,15.4, 15.5, 15.6, 15.7, 15.8, 15.9, 16. , 16.1, 16.2, 16.3, 16.4,16.5, 16.6, 16.7, 16.8, 16.9, 17. , 17.1, 17.2, 17.3, 17.4, 17.5,17.6, 17.7, 17.8, 17.9, 18. , 18.1, 18.2, 18.3, 18.4, 18.5, 18.6,18.7, 18.8, 18.9, 19. , 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7,19.8, 19.9]), shape=2, scale=0.01, c=1.5)</code>","text":"<p>Drift function that follows a scaled gamma distribution</p>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift--arguments","title":"Arguments","text":"<pre><code>!!! t \"np.ndarray &lt;default=np.arange(0, 20, 0.1)&gt;\"\n    Timepoints at which to evaluate the drift.\n    Usually np.arange() of some sort.\n!!! shape \"float &lt;default=2&gt;\"\n    Shape parameter of the gamma distribution\n!!! scale \"float &lt;default=0.01&gt;\"\n    Scale parameter of the gamma distribution\n!!! c \"float &lt;default=1.5&gt;\"\n    Scalar parameter that scales the peak of\n    the gamma distribution.\n    (Note this function follows a gamma distribution\n    but does not integrate to 1)\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.drift_functions.gamma_drift--return","title":"Return","text":"<pre><code>np.ndarray\n    The gamma drift evaluated at the supplied timepoints t.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator","title":"<code>simulator</code>","text":""},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_arbitrary_fptd","title":"<code>bin_arbitrary_fptd(out=None, bin_dt=0.04, nbins=256, nchoices=2, choice_codes=[-1.0, 1.0], max_t=10.0)</code>","text":"<p>Takes in simulator output and returns a histogram of bin counts Arguments</p> <pre><code>!!! out \"tuple\"\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired bin size\n    which in turn automatically determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\n!!! nchoices \"int &lt;default=2&gt;\"\n    Number of choices allowed by the simulator.\nchoice_codes = list &lt;default=[-1.0, 1.0]\n    Choice labels to be used.\n!!! max_t \"float\"\n    Maximum RT to consider.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_arbitrary_fptd--returns","title":"Returns","text":"<pre><code>2d array (nbins, nchoices): A histogram of bin counts\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output","title":"<code>bin_simulator_output(out=None, bin_dt=0.04, nbins=0, max_t=-1, freq_cnt=False)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output--arguments","title":"Arguments","text":"<pre><code>out : tuple\n    Output of the 'simulator' function\nbin_dt : float\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\nnbins : int\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the number of\n    bins automatically.\nmax_t : int &lt;default=-1&gt;\n    Override the 'max_t' metadata as part of the simulator output.\n    Sometimes useful, but usually default will do the job.\nfreq_cnt : bool &lt;default=False&gt;\n    Decide whether to return proportions (default) or counts in bins.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output--returns","title":"Returns","text":"<pre><code>A histogram of counts or proportions.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise","title":"<code>bin_simulator_output_pointwise(out=[0, 0], bin_dt=0.04, nbins=0)</code>","text":"<p>Turns RT part of simulator output into bin-identifier by trial</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--arguments","title":"Arguments","text":"<pre><code>!!! out \"tuple\"\n    Output of the 'simulator' function\n!!! bin_dt \"float\"\n    If nbins is 0, this determines the desired\n    bin size which in turn automatically\n    determines the resulting number of bins.\n!!! nbins \"int\"\n    Number of bins to bin reaction time data into.\n    If supplied as 0, bin_dt instead determines the\n    number of bins automatically.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.bin_simulator_output_pointwise--returns","title":"Returns","text":"<pre><code>2d array. The first columns collects bin-identifiers\nby trial, the second column lists the corresponding choices.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator","title":"<code>simulator(theta, model='angle', n_samples=1000, delta_t=0.001, max_t=20, no_noise=False, bin_dim=None, bin_pointwise=False, smooth_unif=True, random_state=None)</code>","text":"<p>Basic data simulator for the models included in HDDM.</p>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator--arguments","title":"Arguments","text":"<pre><code>theta : list, numpy.array, dict or pd.DataFrame\n    Parameters of the simulator. If 2d array, each row is treated as a 'trial'\n    and the function runs n_sample * n_trials simulations.\n!!! model \"str &lt;default='angle'&gt;\"\n    Determines the model that will be simulated.\n!!! n_samples \"int &lt;default=1000&gt;\"\n    Number of simulation runs for each row in the theta argument.\n!!! delta_t \"float\"\n    Size fo timesteps in simulator (conceptually measured in seconds)\n!!! max_t \"float\"\n    Maximum reaction the simulator can reach\n!!! no_noise \"bool &lt;default=False&gt;\"\n    Turn noise of (useful for plotting purposes mostly)\n!!! bin_dim \"int &lt;default=None&gt;\"\n    Number of bins to use (in case the simulator output is\n    supposed to come out as a count histogram)\n!!! bin_pointwise \"bool &lt;default=False&gt;\"\n    Wheter or not to bin the output data pointwise.\n    If true the 'RT' part of the data is now specifies the\n    'bin-number' of a given trial instead of the 'RT' directly.\n    You need to specify bin_dim as some number for this to work.\n!!! random_state \"int &lt;default=None&gt;\"\n    Integer passed to random_seed function in the simulator.\n    Can be used for reproducibility.\n</code></pre>"},{"location":"api/ssms/#ssms.basic_simulators.simulator.simulator--return","title":"Return","text":"<p>dictionary where keys     can be (rts, responses, metadata)     or     (rt-response histogram, metadata)     or     (rts binned pointwise, responses, metadata)</p>"},{"location":"api/ssms/#ssms.dataset_generators","title":"<code>dataset_generators</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp","title":"<code>lan_mlp</code>","text":""},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator","title":"<code> data_generator        </code>","text":"<p>The data_generator() class is used to generate training data   for various likelihood approximators.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator--attributes","title":"Attributes","text":"<pre><code>!!! generator_config \"dict\"\n    Configuation dictionary for the data generator.\n    (For an example load ssms.config.data_generator_config['lan'])\n!!! model_config \"dict\"\n    Configuration dictionary for the model to be simulated.\n    (For an example load ssms.config.model_config['ddm'])\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator--methods","title":"Methods","text":"<pre><code>generate_data_training_uniform(save=False, verbose=True, cpn_only=False)\n    Generates training data for LANs.\nget_simulations(theta=None, random_seed=None)\n    Generates simulations for a given parameter set.\n_filter_simulations(simulations=None)\n    Filters simulations according to the criteria\n    specified in the generator_config.\n_make_kde_data(simulations=None, theta=None)\n    Generates KDE data from simulations.\n_mlp_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for MLPs.\n_cpn_get_processed_data_for_theta(random_seed_tuple)\n    Helper function for generating training data for CPNs.\n_get_rejected_parameter_setups(random_seed_tuple)\n    Helper function that collectes parameters sets which were rejected\n    by the filter used in the _filter_simulations() method.\n_make_save_file_name(unique_tag=None)\n    Helper function for generating save file names.\n_build_simulator()\n    Builds simulator function for LANs.\n_get_ncpus()\n    Helper function for determining the number of\n    cpus to use for parallelization.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator--returns","title":"Returns","text":"<pre><code>data_generator object\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False, verbose=True, cpn_only=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.lan_mlp.data_generator.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.snpe","title":"<code>snpe</code>","text":""},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe","title":"<code> data_generator_snpe            (data_generator)         </code>","text":"<p>Class for generating data for SNPE.</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe--attributes","title":"Attributes","text":"<p>dict</p> <p>Configuration for data generation</p> <p>dict</p> <p>Configuration for model</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe--methods","title":"Methods","text":"<p>generate_data_training_uniform(save=False)     Generates data for training SNPE. _snpe_get_processed_data_for_theta(random_seed)     Helper function for generating data for SNPE. _build_simulator()     Builds simulator function for SNPE.</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform","title":"<code>generate_data_training_uniform(self, save=False)</code>","text":"<p>Generates training data for LANs.</p>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--arguments","title":"Arguments","text":"<pre><code>!!! save \"bool\"\n    If True, the generated data is saved to disk.\n!!! verbose \"bool\"\n    If True, progress is printed to the console.\n!!! cpn_only \"bool\"\n    If True, only choice probabilities are computed.\n    This is useful for training CPNs.\n</code></pre>"},{"location":"api/ssms/#ssms.dataset_generators.snpe.data_generator_snpe.generate_data_training_uniform--returns","title":"Returns","text":"<pre><code>!!! data \"dict\"\n    Dictionary containing the generated data.\n</code></pre>"},{"location":"api/ssms/#ssms.support_utils","title":"<code>support_utils</code>  <code>special</code>","text":""},{"location":"api/ssms/#ssms.support_utils.kde_class","title":"<code>kde_class</code>","text":""},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE","title":"<code> LogKDE        </code>","text":"<p>Class for generating kdes from (rt, choice) data. Works for any number of choices.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE--attributes","title":"Attributes","text":"<pre><code>!!! simulator_data \"(rt, choice, simulator_info)\"\n    tuple as returned by simulator function\n!!! bandwidth_type \"string\"\n    type of bandwidth to use, default is 'silverman'\n!!! auto_bandwidth \"boolean\"\n    whether to compute bandwidths automatically, default is True\n</code></pre>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE--methods","title":"Methods","text":"<pre><code>compute_bandwidths(type='silverman')\n    Computes bandwidths for each choice from rt data.\ngenerate_base_kdes(auto_bandwidth=True, bandwidth_type='silverman')\n    Generates kdes from rt data.\nkde_eval(data=([], []), log_eval=True)\n    Evaluates kde log likelihood at chosen points.\nkde_sample(n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)\n    Samples from a given kde.\nattach_data_from_simulator(simulator_data=([0, 2, 4], [-1, 1, -1]))\n    Helper function to transform ddm simulator output\n    to dataset suitable for the kde function class.\n</code></pre> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.compute_bandwidths","title":"<code>compute_bandwidths(self, type='silverman')</code>","text":"<p>Computes bandwidths for each choice from rt data.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of bandwidths for each choice.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.generate_base_kdes","title":"<code>generate_base_kdes(self, auto_bandwidth=True, bandwidth_type='silverman')</code>","text":"<p>Generates kdes from rt data. We apply gaussian kernels to the log of the rts.</p> <p>boolean</p> <p>Whether to compute bandwidths automatically, default is True.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of kdes for each choice. (These get attached to the base_kdes attribute of the class, not returned)</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.kde_eval","title":"<code>kde_eval(self, data=([], []), log_eval=True)</code>","text":"<p>Evaluates kde log likelihood at chosen points.</p> <p>tuple</p> <p>Tuple of (rts, choices) to evaluate the kde at.</p> <p>boolean</p> <p>Whether to return log likelihood or likelihood, default is True.</p> <p>array</p> <p>Array of log likelihoods for each (rt, choice) pair.</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.LogKDE.kde_sample","title":"<code>kde_sample(self, n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)</code>","text":"<p>Samples from a given kde.</p> <p>int</p> <p>Number of samples to draw.</p> <p>boolean</p> <p>Whether to use empirical choice proportions, default is True. (Note 'empirical' here, refers to the originally attached datasets that served as the basis to generate the choice-wise kdes)</p> <p>array</p> <p>Array of choice proportions to use, default is 0. (Note 'alternate' here refers to 'alternative' to the 'empirical' choice proportions)</p>"},{"location":"api/ssms/#ssms.support_utils.kde_class.bandwidth_silverman","title":"<code>bandwidth_silverman(sample=[0, 0, 0], std_cutoff=0.001, std_proc='restrict', std_n_1=10)</code>","text":"<p>Computes silverman bandwidth for an array of samples (rts in our context, but general).</p> <p>array</p> <p>Array of samples to compute bandwidth for.</p> <p>float</p> <p>Cutoff for std, default is 1e-3. (If sample-std is smaller than this, we either kill it or restrict it to this value)</p> <p>string</p> <p>How to deal with small stds, default is 'restrict'. (Options: 'kill', 'restrict')</p> <p>float</p> <p>Value to use if n = 1, default is 10. (Not clear if the default is sensible here)</p> <p>float</p> <p>Silverman bandwidth for the given sample. This is applied as the bandwidth parameter when generating gaussian-based kdes in the LogKDE class.</p>"},{"location":"api/support_utils/","title":"Support utils","text":""},{"location":"api/support_utils/#ssms.support_utils.kde_class","title":"<code>kde_class</code>","text":""},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE","title":"<code> LogKDE        </code>","text":"<p>Class for generating kdes from (rt, choice) data. Works for any number of choices.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE--attributes","title":"Attributes","text":"<pre><code>!!! simulator_data \"(rt, choice, simulator_info)\"\n    tuple as returned by simulator function\n!!! bandwidth_type \"string\"\n    type of bandwidth to use, default is 'silverman'\n!!! auto_bandwidth \"boolean\"\n    whether to compute bandwidths automatically, default is True\n</code></pre>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE--methods","title":"Methods","text":"<pre><code>compute_bandwidths(type='silverman')\n    Computes bandwidths for each choice from rt data.\ngenerate_base_kdes(auto_bandwidth=True, bandwidth_type='silverman')\n    Generates kdes from rt data.\nkde_eval(data=([], []), log_eval=True)\n    Evaluates kde log likelihood at chosen points.\nkde_sample(n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)\n    Samples from a given kde.\nattach_data_from_simulator(simulator_data=([0, 2, 4], [-1, 1, -1]))\n    Helper function to transform ddm simulator output\n    to dataset suitable for the kde function class.\n</code></pre> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.compute_bandwidths","title":"<code>compute_bandwidths(self, type='silverman')</code>","text":"<p>Computes bandwidths for each choice from rt data.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of bandwidths for each choice.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.generate_base_kdes","title":"<code>generate_base_kdes(self, auto_bandwidth=True, bandwidth_type='silverman')</code>","text":"<p>Generates kdes from rt data. We apply gaussian kernels to the log of the rts.</p> <p>boolean</p> <p>Whether to compute bandwidths automatically, default is True.</p> <p>string</p> <p>Type of bandwidth to use, default is 'silverman' which follows silverman rule.</p> <p>list</p> <p>List of kdes for each choice. (These get attached to the base_kdes attribute of the class, not returned)</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.kde_eval","title":"<code>kde_eval(self, data=([], []), log_eval=True)</code>","text":"<p>Evaluates kde log likelihood at chosen points.</p> <p>tuple</p> <p>Tuple of (rts, choices) to evaluate the kde at.</p> <p>boolean</p> <p>Whether to return log likelihood or likelihood, default is True.</p> <p>array</p> <p>Array of log likelihoods for each (rt, choice) pair.</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.LogKDE.kde_sample","title":"<code>kde_sample(self, n_samples=2000, use_empirical_choice_p=True, alternate_choice_p=0)</code>","text":"<p>Samples from a given kde.</p> <p>int</p> <p>Number of samples to draw.</p> <p>boolean</p> <p>Whether to use empirical choice proportions, default is True. (Note 'empirical' here, refers to the originally attached datasets that served as the basis to generate the choice-wise kdes)</p> <p>array</p> <p>Array of choice proportions to use, default is 0. (Note 'alternate' here refers to 'alternative' to the 'empirical' choice proportions)</p>"},{"location":"api/support_utils/#ssms.support_utils.kde_class.bandwidth_silverman","title":"<code>bandwidth_silverman(sample=[0, 0, 0], std_cutoff=0.001, std_proc='restrict', std_n_1=10)</code>","text":"<p>Computes silverman bandwidth for an array of samples (rts in our context, but general).</p> <p>array</p> <p>Array of samples to compute bandwidth for.</p> <p>float</p> <p>Cutoff for std, default is 1e-3. (If sample-std is smaller than this, we either kill it or restrict it to this value)</p> <p>string</p> <p>How to deal with small stds, default is 'restrict'. (Options: 'kill', 'restrict')</p> <p>float</p> <p>Value to use if n = 1, default is 10. (Not clear if the default is sensible here)</p> <p>float</p> <p>Silverman bandwidth for the given sample. This is applied as the bandwidth parameter when generating gaussian-based kdes in the LogKDE class.</p>"},{"location":"basic_tutorial/basic_tutorial/","title":"Installation","text":"<p>The <code>ssms</code> package serves two purposes.</p> <ol> <li><p>Easy access to fast simulators of sequential sampling models</p> </li> <li><p>Support infrastructure to construct training data for various approaches to likelihood / posterior amortization</p> </li> </ol> <p>We provide two minimal examples here to illustrate how to use each of the two capabilities.</p> In\u00a0[2]: Copied! <pre># Import necessary packages\nimport numpy as np\nimport pandas as pd\nimport ssms\n</pre> # Import necessary packages import numpy as np import pandas as pd import ssms In\u00a0[3]: Copied! <pre># Check included models\nlist(ssms.config.model_config.keys())[:10]\n</pre> # Check included models list(ssms.config.model_config.keys())[:10] Out[3]: <pre>['ddm',\n 'ddm_legacy',\n 'ddm_deadline',\n 'angle',\n 'weibull',\n 'levy',\n 'levy_angle',\n 'full_ddm',\n 'gamma_drift',\n 'gamma_drift_angle']</pre> In\u00a0[4]: Copied! <pre># Take an example config for a given model\nssms.config.model_config[\"ddm\"]\n</pre> # Take an example config for a given model ssms.config.model_config[\"ddm\"] Out[4]: <pre>{'name': 'ddm',\n 'params': ['v', 'a', 'z', 't'],\n 'param_bounds': [[-3.0, 0.3, 0.1, 0.0], [3.0, 2.5, 0.9, 2.0]],\n 'boundary': &lt;function ssms.basic_simulators.boundary_functions.constant(t=0)&gt;,\n 'n_params': 4,\n 'default_params': [0.0, 1.0, 0.5, 0.001],\n 'hddm_include': ['z'],\n 'nchoices': 2}</pre> <p>Note: The usual structure of these models includes,</p> <ul> <li>Parameter names (<code>'params'</code>)</li> <li>Bounds on the parameters (<code>'param_bounds'</code>)</li> <li>A function that defines a boundary for the respective model (<code>'boundary'</code>)</li> <li>The number of parameters (<code>'n_params'</code>)</li> <li>Defaults for the parameters (<code>'default_params'</code>)</li> <li>The number of choices the process can produce (<code>'nchoices'</code>)</li> </ul> <p>The <code>'hddm_include'</code> key concerns information useful for integration with the hddm python package, which facilitates hierarchical bayesian inference for sequential sampling models. It is not important for the present tutorial.</p> In\u00a0[6]: Copied! <pre>from ssms.basic_simulators.simulator import simulator\n\nsim_out = simulator(\n    model=\"ddm\", theta={\"v\": 0, \"a\": 1, \"z\": 0.5, \"t\": 0.5}, n_samples=1000\n)\n</pre> from ssms.basic_simulators.simulator import simulator  sim_out = simulator(     model=\"ddm\", theta={\"v\": 0, \"a\": 1, \"z\": 0.5, \"t\": 0.5}, n_samples=1000 ) <p>The output of the simulator is a <code>dictionary</code> with three elements.</p> <ol> <li><code>rts</code> (array)</li> <li><code>choices</code> (array)</li> <li><code>metadata</code> (dictionary)</li> </ol> <p>The <code>metadata</code> includes the named parameters, simulator settings, and more.</p> In\u00a0[8]: Copied! <pre>ssms.config.data_generator_config[\"lan\"]\n</pre> ssms.config.data_generator_config[\"lan\"] Out[8]: <pre>{'output_folder': 'data/lan_mlp/',\n 'dgp_list': 'ddm',\n 'nbins': 0,\n 'n_samples': 100000,\n 'n_parameter_sets': 10000,\n 'n_parameter_sets_rejected': 100,\n 'n_training_samples_by_parameter_set': 1000,\n 'max_t': 20.0,\n 'delta_t': 0.001,\n 'pickleprotocol': 4,\n 'n_cpus': 'all',\n 'kde_data_mixture_probabilities': [0.8, 0.1, 0.1],\n 'simulation_filters': {'mode': 20,\n  'choice_cnt': 0,\n  'mean_rt': 17,\n  'std': 0,\n  'mode_cnt_rel': 0.9},\n 'negative_rt_cutoff': -66.77497,\n 'n_subruns': 10,\n 'bin_pointwise': False,\n 'separate_response_channels': False}</pre> <p>You usually have to make just few changes to this basic configuration dictionary. An example below.</p> In\u00a0[9]: Copied! <pre>from copy import deepcopy\n\n# Initialize the generator config (for MLP LANs)\ngenerator_config = deepcopy(ssms.config.data_generator_config[\"lan\"])\n# Specify generative model (one from the list of included models mentioned above)\ngenerator_config[\"dgp_list\"] = \"angle\"\n# Specify number of parameter sets to simulate\ngenerator_config[\"n_parameter_sets\"] = 100\n# Specify how many samples a simulation run should entail\ngenerator_config[\"n_samples\"] = 1000\n</pre> from copy import deepcopy  # Initialize the generator config (for MLP LANs) generator_config = deepcopy(ssms.config.data_generator_config[\"lan\"]) # Specify generative model (one from the list of included models mentioned above) generator_config[\"dgp_list\"] = \"angle\" # Specify number of parameter sets to simulate generator_config[\"n_parameter_sets\"] = 100 # Specify how many samples a simulation run should entail generator_config[\"n_samples\"] = 1000 <p>Now let's define our corresponding <code>model_config</code>.</p> In\u00a0[10]: Copied! <pre>model_config = ssms.config.model_config[\"angle\"]\nprint(model_config)\n</pre> model_config = ssms.config.model_config[\"angle\"] print(model_config) <pre>{'name': 'angle', 'params': ['v', 'a', 'z', 't', 'theta'], 'param_bounds': [[-3.0, 0.3, 0.1, 0.001, -0.1], [3.0, 3.0, 0.9, 2.0, 1.3]], 'boundary': &lt;function angle at 0x125e060c0&gt;, 'n_params': 5, 'default_params': [0.0, 1.0, 0.5, 0.001, 0.0], 'hddm_include': ['z', 'theta'], 'nchoices': 2}\n</pre> <p>We are now ready to initialize a <code>data_generator</code>, after which we can generate training data using the <code>generate_data_training_uniform</code> function, which will use the hypercube defined by our parameter bounds from the <code>model_config</code> to uniformly generate parameter sets and corresponding simulated datasets.</p> In\u00a0[14]: Copied! <pre>my_dataset_generator = ssms.dataset_generators.lan_mlp.data_generator(\n    generator_config=generator_config, model_config=model_config\n)\n</pre> my_dataset_generator = ssms.dataset_generators.lan_mlp.data_generator(     generator_config=generator_config, model_config=model_config ) <pre>n_cpus used:  6\nchecking:  data/lan_mlp/\n</pre> In\u00a0[15]: Copied! <pre>training_data = my_dataset_generator.generate_data_training_uniform(save=False)\n</pre> training_data = my_dataset_generator.generate_data_training_uniform(save=False) <pre>simulation round: 1  of 10\nsimulation round: 2  of 10\nsimulation round: 3  of 10\nsimulation round: 4  of 10\nsimulation round: 5  of 10\nsimulation round: 6  of 10\nsimulation round: 7  of 10\nsimulation round: 8  of 10\nsimulation round: 9  of 10\nsimulation round: 10  of 10\n</pre> <p><code>training_data</code> is a dictionary containing four keys:</p> <ol> <li><code>data</code> the features for LANs, containing vectors of model parameters, as well as rts and choices.</li> <li><code>labels</code> which contain approximate likelihood values</li> <li><code>generator_config</code>, as defined above</li> <li><code>model_config</code>, as defined above</li> </ol> <p>You can now use this training data for your purposes. If you want to train LANs yourself, you might find the LANfactory package helpful.</p> <p>You may also simply find the basic simulators provided with the ssms package useful, without any desire to use the outputs into training data for amortization purposes.</p>"},{"location":"basic_tutorial/basic_tutorial/#quick-start","title":"Quick Start\u00b6","text":""},{"location":"basic_tutorial/basic_tutorial/#install","title":"Install\u00b6","text":"<p>Let's start with installing the <code>ssms</code> package.</p> <p>You can do so by typing,</p> <p><code>pip install git+https://github.com/AlexanderFengler/ssm_simulators</code></p> <p>in your terminal.</p> <p>Below you find a basic tutorial on how to use the package.</p>"},{"location":"basic_tutorial/basic_tutorial/#tutorial","title":"Tutorial\u00b6","text":""},{"location":"basic_tutorial/basic_tutorial/#using-the-simulators","title":"Using the Simulators\u00b6","text":"<p>Let's start with using the basic simulators. You access the main simulators through the  <code>ssms.basic_simulators.simulator</code> function.</p> <p>To get an idea about the models included in <code>ssms</code>, use the <code>config</code> module. The central dictionary with metadata about included models sits in <code>ssms.config.model_config</code>.</p>"},{"location":"basic_tutorial/basic_tutorial/#using-the-training-data-generators","title":"Using the Training Data Generators\u00b6","text":"<p>The training data generators sit on top of the simulator function to turn raw simulations into usable training data for training machine learning algorithms aimed at posterior or likelihood armortization.</p> <p>We will use the <code>data_generator</code> class from <code>ssms.dataset_generators</code>. Initializing the <code>data_generator</code> boils down to supplying two configuration dictionaries.</p> <ol> <li>The <code>generator_config</code>, concerns choices as to what kind of training data one wants to generate.</li> <li>The <code>model_config</code> concerns choices with respect to the underlying generative sequential sampling model.</li> </ol> <p>We will consider a basic example here, concerning data generation to prepare for training LANs.</p> <p>Let's start by peeking at an example <code>generator_config</code>.</p>"},{"location":"basic_tutorial/basic_tutorial/#end","title":"END\u00b6","text":""}]}